<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TinyDolphin&#39;s Blog</title>
  
  <subtitle>不忘初心, 方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.tinydolphin.cn/"/>
  <updated>2018-11-04T09:18:44.456Z</updated>
  <id>https://www.tinydolphin.cn/</id>
  
  <author>
    <name>TinyDolphin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Celery 定时任务</title>
    <link href="https://www.tinydolphin.cn/2018/11/04/Celery/Celery%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    <id>https://www.tinydolphin.cn/2018/11/04/Celery/Celery 定时任务/</id>
    <published>2018-11-04T08:40:22.000Z</published>
    <updated>2018-11-04T09:18:44.456Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-定时任务"><a href="#Celery-定时任务" class="headerlink" title="Celery 定时任务"></a>Celery 定时任务</h1><p>Celery 除了可以执行<strong>异步任务</strong>，也支持执行<strong>周期性任务（Periodic Tasks）</strong>，或者说<strong>定时任务</strong>。<br><br><strong>Celery Beat 进程</strong>通过<strong>读取配置文件的内容，周期性地将定时任务发往任务队列</strong>。</p><p>让我们看看例子，项目结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">celery_demo                    # 项目根目录</span><br><span class="line">    ├── celery_app             # 存放 celery 相关文件</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        ├── celeryconfig.py    # 配置文件</span><br><span class="line">        ├── task1.py           # 任务文件</span><br><span class="line">        └── task2.py           # 任务文件</span><br></pre></td></tr></table></figure><p>__init__.py 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'demo'</span>)                                <span class="comment"># 创建 Celery 实例</span></span><br><span class="line">app.config_from_object(<span class="string">'celery_app.celeryconfig'</span>)   <span class="comment"># 通过 Celery 实例加载配置模块</span></span><br></pre></td></tr></table></figure><p>celeryconfig.py 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line"><span class="comment"># Broker and Backend</span></span><br><span class="line">BROKER_URL = <span class="string">'redis://127.0.0.1:6379'</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://127.0.0.1:6379/0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Timezone</span></span><br><span class="line">CELERY_TIMEZONE=<span class="string">'Asia/Shanghai'</span>    <span class="comment"># 指定时区，不指定默认为 'UTC'</span></span><br><span class="line"><span class="comment"># CELERY_TIMEZONE='UTC'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import</span></span><br><span class="line">CELERY_IMPORTS = (</span><br><span class="line">    <span class="string">'celery_app.task1'</span>,</span><br><span class="line">    <span class="string">'celery_app.task2'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># schedules</span></span><br><span class="line">CELERYBEAT_SCHEDULE = &#123;</span><br><span class="line">    <span class="string">'add-every-30-seconds'</span>: &#123;</span><br><span class="line">         <span class="string">'task'</span>: <span class="string">'celery_app.task1.add'</span>,</span><br><span class="line">         <span class="string">'schedule'</span>: timedelta(seconds=<span class="number">30</span>),       <span class="comment"># 每 30 秒执行一次</span></span><br><span class="line">         <span class="string">'args'</span>: (<span class="number">5</span>, <span class="number">8</span>)                           <span class="comment"># 任务函数参数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'multiply-at-some-time'</span>: &#123;</span><br><span class="line">        <span class="string">'task'</span>: <span class="string">'celery_app.task2.multiply'</span>,</span><br><span class="line">        <span class="string">'schedule'</span>: crontab(hour=<span class="number">9</span>, minute=<span class="number">50</span>),   <span class="comment"># 每天早上 9 点 50 分执行一次</span></span><br><span class="line">        <span class="string">'args'</span>: (<span class="number">3</span>, <span class="number">7</span>)                            <span class="comment"># 任务函数参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>task1.py 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p>task2.py 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure></p><p>现在，让我们启动 <strong>Celery Worker 进程</strong>，在项目的根目录下执行下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyDolphin:celery_demo zhouyonglong01$  celery -A celery_app worker --loglevel=info</span><br></pre></td></tr></table></figure><p>接着，启动 <strong>Celery Beat 进程</strong>，定时将任务发送到 Broker，在项目根目录下执行下面命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyDolphin:celery_demo zhouyonglong01$ celery beat -A celery_app</span><br></pre></td></tr></table></figure></p><p>启动成功，看到如下日志：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">celery beat v4.2.1 (windowlicker) is starting.</span><br><span class="line">__    -    ... __   -        _</span><br><span class="line">LocalTime -&gt; 2018-11-04 16:55:42</span><br><span class="line">Configuration -&gt;</span><br><span class="line">    . broker -&gt; amqp://guest:**@localhost:5672//</span><br><span class="line">    . loader -&gt; celery.loaders.app.AppLoader</span><br><span class="line">    . scheduler -&gt; celery.beat.PersistentScheduler</span><br><span class="line">    . db -&gt; celerybeat-schedule</span><br><span class="line">    . logfile -&gt; [stderr]@%WARNING</span><br><span class="line">    . maxinterval -&gt; 5.00 minutes (300s)</span><br></pre></td></tr></table></figure></p><p>之后，在 Worker 窗口我们可以看到，<strong>任务 task1 每 30 秒执行一次</strong>，而 task2 每天早上 9 点 50 分执行一次。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[2018-11-04 16:56:13,233: INFO/MainProcess] Received task: celery_app.task1.add[3e9324d4-a27b-44a1-b530-d7dcb2c4f27a]</span><br><span class="line">[2018-11-04 16:56:15,254: INFO/ForkPoolWorker-2] Task celery_app.task1.add[3e9324d4-a27b-44a1-b530-d7dcb2c4f27a] succeeded in 2.01500433599s: 13</span><br><span class="line">[2018-11-04 16:56:43,082: INFO/MainProcess] Received task: celery_app.task1.add[e7e1d632-23d9-4c26-9292-d6d56fef70c4]</span><br><span class="line">[2018-11-04 16:56:45,098: INFO/ForkPoolWorker-3] Task celery_app.task1.add[e7e1d632-23d9-4c26-9292-d6d56fef70c4] succeeded in 2.01342217601s: 13</span><br><span class="line">[2018-11-04 16:57:13,082: INFO/MainProcess] Received task: celery_app.task1.add[88467637-a0a7-4357-a17a-b9e564d65d05]</span><br><span class="line">[2018-11-04 16:57:15,085: INFO/ForkPoolWorker-2] Task celery_app.task1.add[88467637-a0a7-4357-a17a-b9e564d65d05] succeeded in 2.00195308999s: 13</span><br></pre></td></tr></table></figure></p><p><strong>PS：在上面，我们用两个命令启动了 Worker 进程和 Beat 进程，我们也可以将它们放在一个命令中：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyDolphin:celery_demo zhouyonglong01$ celery -B -A celery_app worker --loglevel=info</span><br></pre></td></tr></table></figure></p><p>Celery 周期性任务也有多个配置项，可参考<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Python" scheme="https://www.tinydolphin.cn/categories/Python/"/>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/Python/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="Python" scheme="https://www.tinydolphin.cn/tags/Python/"/>
    
      <category term="分布式任务队列" scheme="https://www.tinydolphin.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
      <category term="定时任务" scheme="https://www.tinydolphin.cn/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Celery 调用方法 delay &amp; apply_async 的区别</title>
    <link href="https://www.tinydolphin.cn/2018/11/04/Celery/Celery%20%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%20delay%20&amp;%20apply_async%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://www.tinydolphin.cn/2018/11/04/Celery/Celery 调用方法 delay &amp; apply_async 的区别/</id>
    <published>2018-11-04T08:34:21.000Z</published>
    <updated>2018-11-04T09:03:09.016Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-调用方法-delay-amp-apply-async-的区别"><a href="#Celery-调用方法-delay-amp-apply-async-的区别" class="headerlink" title="Celery 调用方法 delay &amp; apply_async 的区别"></a>Celery 调用方法 delay &amp; apply_async 的区别</h1><p>之前的例子，我们使用了 <strong>delay()</strong> 或 <strong>apply_async()</strong> 方法来调用任务。事实上，<strong>delay 方法封装了 apply_async</strong>，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">(self, *partial_args, **partial_kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Shortcut to :meth:`apply_async` using star arguments."""</span></span><br><span class="line">    <span class="keyword">return</span> self.apply_async(partial_args, partial_kwargs)</span><br></pre></td></tr></table></figure><p>也就是说，delay 是使用 <strong>apply_async 的快捷方式</strong>。<strong>apply_async 支持更多的参数</strong>，它的一般形式如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply_async(args=(), kwargs=&#123;&#125;, route_name=<span class="keyword">None</span>, **options)</span><br></pre></td></tr></table></figure></p><p>apply_async 常用的参数如下：</p><ul><li>countdown：<strong>指定多少秒后执行任务</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">task1.apply_async(args=(<span class="number">2</span>, <span class="number">3</span>), countdown=<span class="number">5</span>)    <span class="comment"># 5 秒后执行任务</span></span><br></pre></td></tr></table></figure><ul><li><p>eta (estimated time of arrival)：<strong>指定任务被调度的具体时间，参数类型是 datetime</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="comment"># 当前 UTC 时间再加 10 秒后执行任务</span></span><br><span class="line">task1.multiply.apply_async(args=[<span class="number">3</span>, <span class="number">7</span>], eta=datetime.utcnow() + timedelta(seconds=<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li><li><p>expires：<strong>任务过期时间，参数类型可以是 int，也可以是 datetime</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task1.multiply.apply_async(args=[3, 7], expires=10)    # 10 秒后过期</span><br></pre></td></tr></table></figure></li></ul><p>更多的参数列表可以在<a href="http://docs.celeryproject.org/en/latest/reference/celery.app.task.html#celery.app.task.Task.apply_async" target="_blank" rel="noopener">官方文档</a>中查看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Python" scheme="https://www.tinydolphin.cn/categories/Python/"/>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/Python/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="Python" scheme="https://www.tinydolphin.cn/tags/Python/"/>
    
      <category term="分布式任务队列" scheme="https://www.tinydolphin.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
      <category term="调用方法" scheme="https://www.tinydolphin.cn/tags/%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Celery 使用配置</title>
    <link href="https://www.tinydolphin.cn/2018/11/04/Celery/Celery%20%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
    <id>https://www.tinydolphin.cn/2018/11/04/Celery/Celery 使用配置/</id>
    <published>2018-11-04T08:04:21.000Z</published>
    <updated>2018-11-04T09:18:59.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-使用配置"><a href="#Celery-使用配置" class="headerlink" title="Celery 使用配置"></a>Celery 使用配置</h1><p>在较大的项目中，采用独立配置模块（中心化保存配置）更为有效，通常我们把文件命名为 celeryconfig.py。Celery 的配置比较多，可以在<a href="http://docs.celeryproject.org/en/latest/userguide/configuration.html" target="_blank" rel="noopener">官方文档</a>查询每个配置项的含义。</p><p>下面，我们再看一个例子。项目结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">celery_demo                    # 项目根目录</span><br><span class="line">    ├── celery_app             # 存放 celery 相关文件</span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── celeryconfig.py    # 配置文件</span><br><span class="line">    │   ├── task1.py           # 任务文件 1</span><br><span class="line">    │   └── task2.py           # 任务文件 2</span><br><span class="line">    └── client.py              # 应用程序</span><br></pre></td></tr></table></figure></p><p>__init__.py 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'demo'</span>)                                <span class="comment"># 创建 Celery 实例</span></span><br><span class="line">app.config_from_object(<span class="string">'celery_app.celeryconfig'</span>)   <span class="comment"># 通过 Celery 实例加载配置模块</span></span><br></pre></td></tr></table></figure><p>celeryconfig.py 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">BROKER_URL = <span class="string">'amqp://guest@localhost:5672//'</span>        <span class="comment"># 指定 Broker</span></span><br><span class="line"></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://127.0.0.1:6379'</span>    <span class="comment"># 指定 Backend</span></span><br><span class="line"></span><br><span class="line">CELERY_TIMEZONE=<span class="string">'Asia/Shanghai'</span>                     <span class="comment"># 指定时区，默认是 UTC</span></span><br><span class="line"><span class="comment"># CELERY_TIMEZONE='UTC'                             </span></span><br><span class="line"></span><br><span class="line">CELERY_IMPORTS = (                                  <span class="comment"># 指定导入的任务模块</span></span><br><span class="line">    <span class="string">'celery_app.task1'</span>,</span><br><span class="line">    <span class="string">'celery_app.task2'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>task1.py 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p>task2.py 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure></p><p>client.py 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> task1</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> task2</span><br><span class="line"></span><br><span class="line">task1.add.apply_async(args=[<span class="number">2</span>, <span class="number">8</span>])        <span class="comment"># 也可用 task1.add.delay(2, 8)</span></span><br><span class="line">task2.multiply.apply_async(args=[<span class="number">3</span>, <span class="number">7</span>])   <span class="comment"># 也可用 task2.multiply.delay(3, 7)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></p><p>现在，让我们启动 Celery Worker 进程，在项目的根目录下执行下面命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyDolphin:celery_demo zhouyonglong01$ celery -A celery_app worker --loglevel=info</span><br></pre></td></tr></table></figure></p><p>接着，运行 python client.py，它会发送两个异步任务到 Broker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TinyDolphin:celery_demo zhouyonglong01$ python client.py</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>在 Worker 的窗口我们可以看到如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[2018-11-04 16:15:26,449: INFO/MainProcess] Received task: celery_app.task1.add[44051062-fdf9-41d0-bccb-6a393c1f2eab]</span><br><span class="line">[2018-11-04 16:15:26,450: INFO/MainProcess] Received task: celery_app.task2.multiply[b3183cc3-0565-4359-b21f-d7fb7c2e22a2]</span><br><span class="line">[2018-11-04 16:15:28,466: INFO/ForkPoolWorker-2] Task celery_app.task1.add[44051062-fdf9-41d0-bccb-6a393c1f2eab] succeeded in 2.012861372s: 10</span><br><span class="line">[2018-11-04 16:15:28,466: INFO/ForkPoolWorker-4] Task celery_app.task2.multiply[b3183cc3-0565-4359-b21f-d7fb7c2e22a2] succeeded in 2.01327455899s: 21</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Python" scheme="https://www.tinydolphin.cn/categories/Python/"/>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/Python/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="Python" scheme="https://www.tinydolphin.cn/tags/Python/"/>
    
      <category term="分布式任务队列" scheme="https://www.tinydolphin.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
      <category term="配置文件" scheme="https://www.tinydolphin.cn/tags/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Celery 异步任务</title>
    <link href="https://www.tinydolphin.cn/2018/11/04/Celery/Celery%20%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>https://www.tinydolphin.cn/2018/11/04/Celery/Celery 异步任务/</id>
    <published>2018-11-04T07:44:31.000Z</published>
    <updated>2018-11-04T10:13:13.282Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-异步任务"><a href="#Celery-异步任务" class="headerlink" title="Celery 异步任务"></a>Celery 异步任务</h1><p>使用 Celery 实现异步任务主要有三个步骤：</p><ol><li>创建一个 Celery 实例；</li><li>启动 Celery worker；</li><li>应用程序调用异步任务。</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="选择-broker-amp-backend"><a href="#选择-broker-amp-backend" class="headerlink" title="选择 broker &amp; backend"></a>选择 broker &amp; backend</h3><ol><li><strong>RabbitMQ</strong>功能齐全，稳定，耐用且易于安装。它是生产环境的绝佳选择。（官网推荐使用）</li><li><strong>Redis</strong>功能齐全，但在突然终止或电源故障时更容易丢失数据</li></ol><p>如果选择以上两种 broker，则需要分别安装，可参考<a href="http://tinydolphin.cn/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Redis/" target="_blank" rel="noopener">Mac 安装 Redis</a> &amp; <a href="http://tinydolphin.cn/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Rabbitmq/" target="_blank" rel="noopener">Mac 安装 Rabbitmq</a> 。</p><h3 id="安装-Celery"><a href="#安装-Celery" class="headerlink" title="安装 Celery"></a>安装 Celery</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install celery</span><br></pre></td></tr></table></figure><h2 id="创建-Celery-任务"><a href="#创建-Celery-任务" class="headerlink" title="创建 Celery 任务"></a>创建 Celery 任务</h2><p>将下面的代码保存为文件 tasks.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">broker = <span class="string">'amqp://guest@localhost:5672//'</span></span><br><span class="line">backend = <span class="string">'redis://127.0.0.1:6379'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Celery 实例</span></span><br><span class="line"><span class="comment"># 第一个参数：当前模板的名称。只有在 __main__ 模板中定义任务时才能自动生成名称。</span></span><br><span class="line"><span class="comment"># 第二个参数：指定使用的消息中间件的 URL</span></span><br><span class="line"><span class="comment"># 第三个参数：指定任务结果存储的 URL</span></span><br><span class="line">app = Celery(<span class="string">'tasks'</span>, broker=broker, backend=backend)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为 add 的单个任务：返回两个数的总和</span></span><br><span class="line"><span class="comment"># 创建了一个 Celery 任务 add，当函数被 @app.task 装饰后，就成为可被 Celery 调度的任务</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)   <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><h2 id="启动-Celery-worker"><a href="#启动-Celery-worker" class="headerlink" title="启动 Celery worker"></a>启动 Celery worker</h2><p>在当前目录下，使用以下指令启动 Celery worker：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -A tasks --loglevel=info</span><br></pre></td></tr></table></figure></p><p>其中，</p><ul><li>参数 -A 指定了 Celery 实例的位置，本例是在 tasks.py 中，Celery 会自动在该文件中寻找 Celery 对象实例，当然，我们也可以自己指定，在本例，使用 -A tasks.app。</li><li>参数 –loglevel 指定了日志级别，默认为 warning，也可以使用 -l info 来表示；</li></ul><p>启动成功后，控制台会显示如下输出：</p><p><img src="/images/celery启动成功.jpg" alt="celery启动成功.jpg"></p><h2 id="调度任务"><a href="#调度任务" class="headerlink" title="调度任务"></a>调度任务</h2><p>现在，我们可以在应用程序中使用 <strong>delay()</strong> 或 <strong>apply_async()</strong> 方法来调用任务。</p><p>在当前目录打开 Python 控制台，输入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tasks <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.delay(<span class="number">1</span>, <span class="number">20</span>)</span><br><span class="line">&lt;AsyncResult: d91cb44d-e4b5<span class="number">-489</span>b<span class="number">-9</span>dbf<span class="number">-982</span>ae2b39e0d&gt;</span><br></pre></td></tr></table></figure><p>在上面，我们从 tasks.py 文件中<strong>导入了 add 任务对象，然后使用 delay() 方法将任务发送到消息中间件（Broker），Celery Worker 进程监控到该任务后，就会进行执行</strong>。我们将窗口切换到 Worker 的启动窗口，会看到多了两条日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2018-11-04 15:43:25,351: INFO/MainProcess] Received task: tasks.add[d91cb44d-e4b5-489b-9dbf-982ae2b39e0d]</span><br><span class="line">[2018-11-04 15:43:25,386: INFO/ForkPoolWorker-2] Task tasks.add[d91cb44d-e4b5-489b-9dbf-982ae2b39e0d] succeeded in 0.0192078250111s: 21</span><br></pre></td></tr></table></figure><p>这说明任务已经被调度并执行成功。</p><p>PS：我们如果想获取执行后的结果，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = add.delay(<span class="number">10</span>, <span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()  <span class="comment"># 使用 ready() 判断任务是否执行完毕</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.get()    <span class="comment"># 使用 get() 获取任务结果</span></span><br><span class="line"><span class="number">52</span></span><br></pre></td></tr></table></figure><p>注意：虽然执行 add 方法 5s 之后才会返回结果，但是这是一个异步任务，不会阻塞主程序的，因此主程序并不会等待，而是会继续向下执行。</p><h2 id="后台启动-Celery-worker"><a href="#后台启动-Celery-worker" class="headerlink" title="后台启动 Celery worker"></a>后台启动 Celery worker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">celery multi start worker -A tasks -l info</span><br><span class="line">celery multi restart worker -A tasks -l info</span><br><span class="line"># 不等待worker关闭</span><br><span class="line">celery multi stop worker -A tasks -l info</span><br><span class="line"># 等待worker关闭</span><br><span class="line">celery multi stopwait worker -A tasks -l info</span><br></pre></td></tr></table></figure><p>注意：celery multi 不会存储有关 worker 的信息，因此在<strong>重启时，需要使用相同的命令行参数</strong>。<strong>停止时，只能使用相同的 pidfile 和 logfile 参数</strong>。</p><p>默认情况下，它会<strong>在当前目录中创建pid和日志文件，以防止多个工作人员在彼此之上启动</strong>，但是推荐你将这些文件放在专用目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/run/celery</span><br><span class="line">mkdir -p /var/log/celery</span><br><span class="line">celery multi start w1 -A proj -l info --pidfile=/var/run/celery/%n.pid --logfile=/var/log/celery/%n%I.log</span><br></pre></td></tr></table></figure><p>使用multi命令可以<strong>启动多个worker</strong>，并且还有一个强大的命令行语法来为不同的worker指定参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery multi start 10 -A proj -l info -Q:1-3 images,video -Q:4,5 data -Q default -L:4,5 debug</span><br></pre></td></tr></table></figure></p><p>有关更多示例，请参考<a href="http://docs.celeryproject.org/en/master/reference/celery.bin.multi.html#module-celery.bin.multi" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Python" scheme="https://www.tinydolphin.cn/categories/Python/"/>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/Python/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="Python" scheme="https://www.tinydolphin.cn/tags/Python/"/>
    
      <category term="分布式任务队列" scheme="https://www.tinydolphin.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
      <category term="异步" scheme="https://www.tinydolphin.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>Celery 框架及其使用场景</title>
    <link href="https://www.tinydolphin.cn/2018/11/04/Celery/Celery%20%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://www.tinydolphin.cn/2018/11/04/Celery/Celery 框架及其使用场景/</id>
    <published>2018-11-04T06:28:22.000Z</published>
    <updated>2018-11-04T09:02:58.679Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-框架及其使用场景"><a href="#Celery-框架及其使用场景" class="headerlink" title="Celery 框架及其使用场景"></a>Celery 框架及其使用场景</h1><p>celery 是一款基于 python 开发的、专注于<strong>实时处理</strong>和<strong>任务调度</strong>的<strong>分布式任务队列</strong>。</p><h2 id="Celery-架构以及组成部分"><a href="#Celery-架构以及组成部分" class="headerlink" title="Celery 架构以及组成部分"></a>Celery 架构以及组成部分</h2><p><img src="/images/celery.jpg" alt="Celery 框架图"></p><p>可以看到，Celery 主要包含以下几个模块：</p><h3 id="任务模板-Task"><a href="#任务模板-Task" class="headerlink" title="任务模板 Task"></a>任务模板 Task</h3><p><strong>异步任务：</strong>通常在业务逻辑中<strong>被触发</strong>并发往任务队列。<br><br><strong>定时任务：</strong>由 <strong>Celery Beat</strong> 进程<strong>周期性</strong>地将任务发往任务队列。</p><h3 id="消息中间件-Broker"><a href="#消息中间件-Broker" class="headerlink" title="消息中间件 Broker"></a>消息中间件 Broker</h3><p>即为<strong>任务调度队列</strong>，<strong>接收任务生产者发来的消息（即任务），将任务存入队列，再按序分发给任务消费者</strong>。Celery 本身不提供队列服务，官方推荐使用 RabbitMQ 和 Redis 等。</p><h3 id="任务执行单元-Worker"><a href="#任务执行单元-Worker" class="headerlink" title="任务执行单元 Worker"></a>任务执行单元 Worker</h3><p>Worker 是执行任务的处理单元，它<strong>实时监控消息队列，获取队列中调度的任务，并执行它</strong>。</p><h3 id="任务结果存储-Backend"><a href="#任务结果存储-Backend" class="headerlink" title="任务结果存储 Backend"></a>任务结果存储 Backend</h3><p>Backend 用于<strong>存储任务的执行结果，以供查询</strong>。同消息中间件一样，存储也可使用 RabbitMQ, Redis 和 MongoDB 等。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>例子一：在程序的运行过程中，经常会碰到一些耗时耗资源的操作，为了避免它们阻塞主程序的运行，我们经常会采用多线程或异步任务。</strong></p><p>比如：在 web 开发中，对新用户的注册，我们通常会给他发一封激活邮件，而发邮件就是 IO阻塞式任务，如果它们直接放到应用当中，就需要等到邮件发出去之后，才能进行下一步操作，此时用户只有一直等待。</p><p>celery 解决方案：在业务逻辑中<strong>触发一个发邮件的异步任务</strong>，而主程序可以继续往下运行。</p><p><strong>例子二：在程序运行的过程中，有一个要运行很久的任务，但是我们又不想阻塞主程序</strong>。</p><ol><li>解决方案：使用多线程。但是当<strong>并发量过大</strong>时，多线程也会扛不住</li><li>继续解决：使用线程池来限制并发数。<ul><li>多线程对于<strong>共享资源</strong>的使用也是比较麻烦的一件事。</li><li>对于<strong>协程</strong>，它还是在同一个线程中执行的，如果一个任务本身的执行时间很长，而不是因为等待 IO 被挂起的，那么也同样会阻塞其他的协程。</li></ul></li><li>最终方案：基于以上的问题，我们可以使用一个强大的分布式任务队列 Celery 来<strong>让任务的执行和主程序完全的脱离</strong>，甚至不在同一个主机内。通过<strong>队列</strong>来调度任务，所以不用担心并发量高时导致系统负载过大。</li></ol><p><strong>例子三：执行和主程序脱离</strong></p><p>你想对100台机器执行一条批量命令，可能会花很长时间 ，但你不想让你的程序等着结果返回，而是给你返回一个任务ID,你过一段时间只需要拿着这个任务id就可以拿到任务执行结果，这样的话，在任务执行进行时，你可以继续做其它的事情。</p><p><strong>例子四：做一个定时任务</strong></p><p>比如每天定时检测一下你们所有客户的资料，如果发现今天是客户的生日，就给他发个短信祝福</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Python" scheme="https://www.tinydolphin.cn/categories/Python/"/>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/Python/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="Python" scheme="https://www.tinydolphin.cn/tags/Python/"/>
    
      <category term="分布式任务队列" scheme="https://www.tinydolphin.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
      <category term="框架" scheme="https://www.tinydolphin.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</title>
    <link href="https://www.tinydolphin.cn/2018/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%B5%85%E6%9E%90%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E3%80%81%E5%B9%B3%E5%9D%87%E3%80%81%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://www.tinydolphin.cn/2018/10/28/数据结构与算法/复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度/</id>
    <published>2018-10-28T14:45:33.000Z</published>
    <updated>2018-10-28T13:51:56.296Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"><a href="#复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"></a>复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</h1><p>主要四个复杂度分析方面的知识点：<strong>最好情况时间复杂度</strong>、<strong>最坏情况时间复杂度</strong>、<strong>平均情况时间复杂度</strong>、<strong>均摊时间复杂度</strong></p><h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，我们上一节简单的分析方法，解决不了这个问题。</p><p>第一种情况：如果数组中第一个元素正好是要查找的变量 x ，那么就不需要继续遍历剩下的 n - 1 个数据了，那么时间复杂度：O(1)</p><p>第二种情况：如果数组中不存在要查找的变量 x ，那就需要把整个数组都遍历一遍，时间复杂度就成了：O(n)</p><p>所以：不同的情况下，这段代码的复杂度不一样。</p><p>①、<strong>最好情况时间复杂度</strong>就是，在<strong>最理想</strong>的情况下，执行这段代码的时间复杂度。</p><p>②、<strong>最坏情况时间复杂度</strong>就是，在<strong>最糟糕</strong>的情况下，执行这段代码的时间复杂度。</p><h2 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h2><h3 id="不考虑变量-x-在数组中出现的概率问题（结论正确，但是分析过程有点问题）"><a href="#不考虑变量-x-在数组中出现的概率问题（结论正确，但是分析过程有点问题）" class="headerlink" title="不考虑变量 x 在数组中出现的概率问题（结论正确，但是分析过程有点问题）"></a>不考虑变量 x 在数组中出现的概率问题（结论正确，但是分析过程有点问题）</h3><p>拿上面的代码来分析，要查找变量 x 在数组中的位置，有 n + 1 种情况：<strong>在数组 0 ~ n -1 位置中和不在数组中</strong>。这样的话，我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n + 1 ，就可以得到需要遍历的元素个数的平均值了，即：(1 + 2 + 3 …… + n + n ) / (n+1) = n(n+3) / 2(n+1) 。</p><p>但是在时间复杂度大 O 标记法中，可以省略掉系数、低阶、常量，所以简化之后，得到的平均时间复杂度就是 O(n)。</p><h3 id="考虑变量-x-在数组中出现的概率问题"><a href="#考虑变量-x-在数组中出现的概率问题" class="headerlink" title="考虑变量 x 在数组中出现的概率问题"></a>考虑变量 x 在数组中出现的概率问题</h3><p>为了方便理解，我们假设在数组中和不在数组中的概率都为 1/2 。要查找的数据出现在 0 ~ n-1 这 n 个位置的概率也是一样的，为 1/n 。所以，根据概率乘法法则，要查找的元素出现在 0 ~ n-1 中任意位置的概率为 1/(2n)。</p><p>那么考虑概率的话，计算过程：1 <em> 1/(2n) + 2 </em> 1/(2n) + 3 <em> 1/(2n) + …… + n </em> 1/(2n) + n * 1/2 = (1+3n)/4 ，用大 O 表示法来表示，这段代码的加权平均时间复杂度仍然是 O(n) 。</p><p>这个值就是概率论中的<strong>加权平均值</strong>，也叫做<strong>期望值</strong>，所以<strong>平均时间复杂度</strong>的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p><h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现的功能：往数组中插入数据。当数组满了之后，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，再将新的数据插入。</span></span><br><span class="line"><span class="comment">// array 表示一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == <span class="built_in">array</span>.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; ++i) &#123;</span><br><span class="line">         sum = sum + <span class="built_in">array</span>[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">array</span>[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">array</span>[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用之前的方式去分析时间复杂度"><a href="#利用之前的方式去分析时间复杂度" class="headerlink" title="利用之前的方式去分析时间复杂度"></a>利用之前的方式去分析时间复杂度</h3><p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置即可，所以最好情况时间复杂度为 O(1)。</p><p>最坏的情况下，数组中没有空闲空间，我们需要做一次数组遍历求和，然后再将数据插入，所以最坏的情况为 O(n) </p><p>平均时间复杂度下，根据数据插入的位置不同，我们可以分为 n 种情况，每种情况的时间复杂度为 O(1) 。除此之外，还有一种”额外”的情况，就是在数组没有空闲空间的插入一个数据时，时间复杂度为 O(n)，而且这 n + 1 种情况发生的概率一样，都是 1/(n+1) 。所以，根据加权平均的计算方法，我们可以得到平均时间复杂度：1 <em> 1/(n+1) + 1 </em> 1/(n+1) + 1 <em> 1/(n+1) …… 1 </em> 1/(n+1) + n * 1/(n+1) = 2n/(n+1) —&gt; O(1) </p><h3 id="利用摊还分析法去分析时间复杂度"><a href="#利用摊还分析法去分析时间复杂度" class="headerlink" title="利用摊还分析法去分析时间复杂度"></a>利用摊还分析法去分析时间复杂度</h3><p><strong>①、首先来看看 insert() 与 find() 的区别：</strong></p><ul><li>find() 函数在极端的情况下，复杂度才为 O(1) ，但 <strong>insert() 在大多数情况下，时间复杂度都为 O(1)</strong>，只有个别情况下，复杂度才为 O (n) ；</li><li>对于 insert() 函数来说，O(1) 时间复杂度的插入和O(n) 时间复杂度的插入，出现的频率非常的有规律，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟 n-1 个O(1) 的插入操作，循环往复。 </li></ul><p>基于以上两种不同，我们可以引入一种更加简单的分析方法：摊还分析法。通过这种方法得到的时间复杂度，就叫做：<strong>均摊时间复杂度</strong>。</p><p><strong>②、如何使用摊还分析法来分析算法的均摊时间复杂度</strong></p><p>大致思路：每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时小的操作上，均摊下来，这一组的连续的操作的均摊时间复杂度就是 O(1) 。</p><p>均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。其实<strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>对一个数据结构进行一组连续的操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块分析，看是否能够将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且这种情况下，一般均摊时间复杂度就等于最好情况时间复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.tinydolphin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://www.tinydolphin.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://www.tinydolphin.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</title>
    <link href="https://www.tinydolphin.cn/2018/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%EF%BC%9F/"/>
    <id>https://www.tinydolphin.cn/2018/10/28/数据结构与算法/复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？/</id>
    <published>2018-10-28T12:25:35.000Z</published>
    <updated>2018-10-28T14:03:35.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"><a href="#复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？" class="headerlink" title="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"></a>复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</h1><p><strong>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半</strong></p><blockquote><p><strong>Q：为什么需要复杂度分析？</strong></p><p>A：首页对于这个问题有所疑惑：明明可以把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小（某些书中的”事后统计法”）。为什么还需要复杂度分析呢？</p><p>因为这种方法存在很大的<strong>局限性</strong>：</p><p>①、<strong>测试结果非常的依赖测试环境</strong><br><br>    不同的测试环境，得到的结果可能完全不同。</p><p>②、<strong>测试结果受数据规模的影响很大</strong><br><br>    比如：排序算法中，对于不一样的待排序数据有序度，排序的执行时间就有很大的差别。（对于小规模的数据排序，插入排序可能反倒会比快速排序要快！）</p><p>所以，我们需要一个<strong>不用具体的测试数据来测试</strong>，就可以<strong>粗略地估算出算法的执行效率</strong>的方法——<strong>时间、空间复杂度分析</strong>。</p></blockquote><h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2><p>我们假设每一段代码的执行时间为 t</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;             <span class="comment">// 一个 t 的执行时间 </span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;               <span class="comment">// t</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;    <span class="comment">// n * t</span></span><br><span class="line">    sum = sum + i;         <span class="comment">// n * t</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 所以这段代码的总的执行时间 T(n) = (2n+2)*t 。可以看出：<strong>总的代码执行时间 T(n) 与每行代码的执行次数成正比</strong>。</p><p>所以，这段代码的大 O 时间复杂度表示法： <strong>T(n) = O(f(n))</strong></p><p>其中：T(n)：代码总的执行时间、n：数据规模的大小、f(n) 每行代码执行的次数总和、O ：代码的执行时间 T(n) 与 f(n) 表达式成正比</p><p>大 O 时间复杂度表示法：并不具体表示代码的真正执行时间，而是表示<strong>代码执行时间随着数据规模增长的变化趋势</strong>。也叫 <strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong></p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="1、只关注循环执行次数最大的一段代码"><a href="#1、只关注循环执行次数最大的一段代码" class="headerlink" title="1、只关注循环执行次数最大的一段代码"></a>1、只关注循环执行次数最大的一段代码</h3><p>既然说大 O 复杂度是一种变化趋势，那么我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">// 常量级别的执行时间，与 n 无关，可以忽略</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">// 同上</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;<span class="comment">// n</span></span><br><span class="line">    sum = sum + i;<span class="comment">// n</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以以上代码，总的时间复杂度：O(n)</p><h3 id="2、加法规则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2、加法规则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2、加法规则：总复杂度等于量级最大的那段代码的复杂度"></a>2、加法规则：总复杂度等于量级最大的那段代码的复杂度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">true<span class="comment">// 常量级别</span></span><br><span class="line">   <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line">true<span class="comment">// O(n) 级别</span></span><br><span class="line">   <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// O(n²) 级别</span></span><br><span class="line">   <span class="keyword">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以以上代码，总的时间复杂度：T(n) = T1(n) + T2(n) + T3(n) = O(1) + O(n) + O(n²) = O(n²) </p><p>如果 T1(n) = O(f(n))、T2(n) = O(g(n))；那么T(n) = T1(n) + T2(n) = Max(O(f(n),  g(n)))</p><h3 id="3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">true<span class="comment">// O(n) 级别</span></span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// O(n) 级别</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以以上代码，总的时间复杂度：T = T1(n) <em> T2(n) = O(n </em> n) = O(n²) </p><p>如果 T1(n) = O(f(n))、T2(n) = O(g(n))；那么T(n) = T1(n) <em> T2(n) = O(f(n) </em> g(n))</p><h2 id="几种常见的时间复杂度实例分析"><a href="#几种常见的时间复杂度实例分析" class="headerlink" title="几种常见的时间复杂度实例分析"></a>几种常见的时间复杂度实例分析</h2><h3 id="1、多项式时间复杂度"><a href="#1、多项式时间复杂度" class="headerlink" title="1、多项式时间复杂度"></a>1、多项式时间复杂度</h3><p>常量阶 O(1)、对数阶 O(logn)、线性阶 O(n)、线性对数阶 O(nlogn)、平方阶 O(n²)、立方阶 O(n³) …… K方阶 O(n^k)</p><h4 id="①、O-1"><a href="#①、O-1" class="headerlink" title="①、O(1)"></a>①、O(1)</h4><p>一般情况下，只要算法中不存在循环语句，递归语句，就算有成千上万行代码，其时间复杂度依然是 O(1)</p><h4 id="②、O-logn、nlogn"><a href="#②、O-logn、nlogn" class="headerlink" title="②、O(logn、nlogn)"></a>②、O(logn、nlogn)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设第三行代码的执行次数为 x ，则可以得到 2^x = n，进而得到 x = log2(n) 。所以这段代码的时间复杂度为 O(log2(n))。</p><p>由于前面我们说过，<strong>在使用大O标记复杂度的时候，可以忽略系数</strong>。所以，在对数阶时间复杂度的时候，我们忽略对数的底，统一表示为 O(logn)</p><h4 id="③、O-n-m-、O-n-m"><a href="#③、O-n-m-、O-n-m" class="headerlink" title="③、O(n+m)、O(n*m)"></a>③、O(n+m)、O(n*m)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，出现两个无法预知 n、m 的数据规模量级大小，所以不能简单的利用加法法则，省略掉其中一个。所以以上代码的时间复杂度：T1(n) + T1(m) = O(f(n) + g(m)) = O(n+m)。</p><p>虽然此时加法法则无效，但是乘法法则依然有效：T1(n) <em> T2(m) = O(f(n) </em> g(m))  = O(n * m)</p><h3 id="2、非多项式时间复杂度（非常低效的方法，直接略）"><a href="#2、非多项式时间复杂度（非常低效的方法，直接略）" class="headerlink" title="2、非多项式时间复杂度（非常低效的方法，直接略）"></a>2、非多项式时间复杂度（非常低效的方法，直接略）</h3><p>指数阶 O(2^n)、阶乘阶 O(n!) 。</p><p>对于这个时间复杂度，会随着数据规模的增长，算法的执行时间会急剧增加。所以非常的低效。</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>前面讲过，时间复杂度的全称是<strong>渐进时间复杂度</strong>，表示<strong>算法的执行时间与数据规模之间的增长关系</strong>。那么类比一下，<strong>空间复杂度</strong>就是<strong>渐进空间复杂度</strong>，表示<strong>算法的存储空间与数据规模之间的增长关系</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 常量阶，申请了一个空间存储变量 i</span></span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">// 一个大小为 n 的 int 型数组</span></span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，以上的空间复杂度：O(n) </p><p>常见的空间复杂度：O(1)、O(n)、O(n²)，像 O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都要分析一下时间复杂度、空间复杂度是不是很浪费时间呢？你怎么看待这个问题呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.tinydolphin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://www.tinydolphin.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://www.tinydolphin.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装 brew 以及部分使用指令</title>
    <link href="https://www.tinydolphin.cn/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20%20brew%20%E4%BB%A5%E5%8F%8A%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://www.tinydolphin.cn/2018/09/17/工具/Mac 安装  brew 以及部分使用指令/</id>
    <published>2018-09-17T15:22:54.000Z</published>
    <updated>2018-10-28T13:49:54.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-安装-brew-以及部分使用指令"><a href="#Mac-安装-brew-以及部分使用指令" class="headerlink" title="Mac 安装 brew 以及部分使用指令"></a>Mac 安装 brew 以及部分使用指令</h1><h3 id="NO-1-官网获取下载指令"><a href="#NO-1-官网获取下载指令" class="headerlink" title="NO.1 官网获取下载指令"></a>NO.1 官网获取下载指令</h3><p><a href="http://brew.sh/" target="_blank" rel="noopener">http://brew.sh/</a></p><p>Homebrew安装成功后，会自动创建目录 /usr/local/Cellar 来存放Homebrew安装的程序</p><h3 id="NO-2-使用-brew"><a href="#NO-2-使用-brew" class="headerlink" title="NO.2 使用 brew"></a>NO.2 使用 brew</h3><ul><li>安装软件：brew install 软件名，例：brew install wget</li><li>搜索软件：brew search 软件名，例：brew search wget</li><li>卸载软件：brew uninstall 软件名，例：brew uninstall wget</li><li>更新所有软件：brew update</li><li>更新具体软件：brew upgrade 软件名 ，例：brew upgrade git</li><li>显示已安装软件：brew list</li><li>查看软件信息：brew info／home 软件名 ，例：brew info git ／ brew home git<br>PS：brew home指令是用浏览器打开官方网页查看软件信息</li><li>查看哪些已安装的程序需要更新： brew outdated</li><li>显示包依赖：brew reps</li><li>显示帮助：brew help</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="https://www.tinydolphin.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装 Rabbitmq</title>
    <link href="https://www.tinydolphin.cn/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Rabbitmq/"/>
    <id>https://www.tinydolphin.cn/2018/09/17/工具/Mac 安装 Rabbitmq/</id>
    <published>2018-09-17T15:22:54.000Z</published>
    <updated>2018-10-28T13:49:59.500Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-安装-Rabbitmq"><a href="#Mac-安装-Rabbitmq" class="headerlink" title="Mac 安装 Rabbitmq"></a>Mac 安装 Rabbitmq</h1><h3 id="NO-1-Mac-下安装-Rabbitmq"><a href="#NO-1-Mac-下安装-Rabbitmq" class="headerlink" title="NO.1 Mac 下安装 Rabbitmq"></a>NO.1 Mac 下安装 Rabbitmq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" # 安装 brew（Homebrew：Mac OS平台下的软件包管理工具）</span><br><span class="line">brew install rabbitmq</span><br><span class="line">sudo vim ~/.bash_profile</span><br><span class="line">PATH=$PATH:/usr/local/sbin # 最后一行加上</span><br></pre></td></tr></table></figure><h3 id="NO-2-启动-amp-停止-Rabbitmq"><a href="#NO-2-启动-amp-停止-Rabbitmq" class="headerlink" title="NO.2 启动 &amp; 停止 Rabbitmq"></a>NO.2 启动 &amp; 停止 Rabbitmq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动服务</span><br><span class="line">brew services start rabbitmq</span><br><span class="line"><span class="meta">#</span> 停止服务</span><br><span class="line">brew services stop rabbitmq</span><br><span class="line"><span class="meta">#</span> 启用插件</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"><span class="meta">#</span> 禁用插件</span><br><span class="line">rabbitmq-plugins disable rabbitmq_management</span><br></pre></td></tr></table></figure><h3 id="NO-3-进入控制台"><a href="#NO-3-进入控制台" class="headerlink" title="NO.3 进入控制台"></a>NO.3 进入控制台</h3><p><a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p><p>默认用户名和密码：guest , guest</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Rabbitmq" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/Rabbitmq/"/>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/Rabbitmq/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="https://www.tinydolphin.cn/tags/Mac/"/>
    
      <category term="Rabbitmq" scheme="https://www.tinydolphin.cn/tags/Rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装 Redis</title>
    <link href="https://www.tinydolphin.cn/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Redis/"/>
    <id>https://www.tinydolphin.cn/2018/09/17/工具/Mac 安装 Redis/</id>
    <published>2018-09-17T15:22:54.000Z</published>
    <updated>2018-10-30T02:58:50.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-安装-Redis"><a href="#Mac-安装-Redis" class="headerlink" title="Mac 安装 Redis"></a>Mac 安装 Redis</h1><h3 id="NO-1-Mac-下安装-Redis"><a href="#NO-1-Mac-下安装-Redis" class="headerlink" title="NO.1 Mac 下安装 Redis"></a>NO.1 Mac 下安装 Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure><h3 id="NO-2-启动-amp-停止-Rabbitmq"><a href="#NO-2-启动-amp-停止-Rabbitmq" class="headerlink" title="NO.2 启动 &amp; 停止 Rabbitmq"></a>NO.2 启动 &amp; 停止 Rabbitmq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动Redis服务</span><br><span class="line">brew services start redis</span><br><span class="line"><span class="meta">#</span> 关闭Redis服务</span><br><span class="line">brew services stop redis</span><br><span class="line"><span class="meta">#</span> 重启Redis服务</span><br><span class="line">brew services restart redis</span><br><span class="line"><span class="meta">#</span> 打开图形化界面</span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure><h3 id="NO-3-redise的配置文件所在路径"><a href="#NO-3-redise的配置文件所在路径" class="headerlink" title="NO.3 redise的配置文件所在路径"></a>NO.3 redise的配置文件所在路径</h3><p>/usr/local/etc/redis.conf</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Redis" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/Redis/"/>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/Redis/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="https://www.tinydolphin.cn/tags/Mac/"/>
    
      <category term="Redis" scheme="https://www.tinydolphin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1852 Ants</title>
    <link href="https://www.tinydolphin.cn/2018/09/15/ACM/POJ/1852/"/>
    <id>https://www.tinydolphin.cn/2018/09/15/ACM/POJ/1852/</id>
    <published>2018-09-15T14:45:33.000Z</published>
    <updated>2018-10-28T13:50:19.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="POJ-1852-Ants"><a href="#POJ-1852-Ants" class="headerlink" title="POJ 1852 Ants"></a>POJ 1852 Ants</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    POJ:1852</span></span><br><span class="line"><span class="comment">    题意：简单的理解就是， N 只蚂蚁以 1cm/s 的速度在，一条长 L 厘米的竿子上爬行（不知道初始的爬行方向），当蚂蚁爬到竿子的端点时会掉落。</span></span><br><span class="line"><span class="comment">        但竿子太细了，如果有两只蚂蚁相遇时，它们只能各自反向爬回去。</span></span><br><span class="line"><span class="comment">        对于蚂蚁，我们只知道它们距离竿子左端的距离 xi，但不知道当前蚂蚁的朝向</span></span><br><span class="line"><span class="comment">        请计算所有蚂蚁落下竿子所需要的最短时间和最长时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    迷惑条件：如果有两只蚂蚁相遇时，它们只能各自反向爬回去。</span></span><br><span class="line"><span class="comment">    转换思路：其实不管相遇后各自反向爬 OR 相遇后保持原方向爬行，结果都是一样的。</span></span><br><span class="line"><span class="comment">    这样的话，最短时间 = MAX（所有蚂蚁距离竿子端点的最近距离）</span></span><br><span class="line"><span class="comment">            最长时间 = MAX（所有蚂蚁距离竿子端点的最远距离）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000010 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,l,x[MAX_N];</span><br><span class="line"><span class="keyword">int</span> maxT, minT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    minT = <span class="number">0</span>;</span><br><span class="line">    maxT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">        minT = max(minT, min(x[i], l - x[i]));</span><br><span class="line">        maxT = max(maxT, max(x[i], l - x[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l , &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, minT, maxT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="ACM" scheme="https://www.tinydolphin.cn/categories/ACM/"/>
    
    
      <category term="ACM" scheme="https://www.tinydolphin.cn/tags/ACM/"/>
    
      <category term="POJ" scheme="https://www.tinydolphin.cn/tags/POJ/"/>
    
      <category term="C++" scheme="https://www.tinydolphin.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>JetBrains系开发工具激活</title>
    <link href="https://www.tinydolphin.cn/2018/09/11/%E5%B7%A5%E5%85%B7/JetBrains%E7%B3%BB%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%BF%80%E6%B4%BB/"/>
    <id>https://www.tinydolphin.cn/2018/09/11/工具/JetBrains系开发工具激活/</id>
    <published>2018-09-11T01:06:23.000Z</published>
    <updated>2018-10-28T13:49:49.426Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>NO.1</strong></p><p>将“0.0.0.0 account.jetbrains.com”添加到 <strong>hosts 文件末尾处</strong></p><p>hosts 文件所在目录：</p><ul><li><p>Windows：C:\Windows\System32\drivers\etc\hosts</p></li><li><p>Mac：/etc/hosts</p></li></ul><p><strong>NO.2</strong></p><p>进入 <a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a> ，获得注册码即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Mac终端添加ll、la、l命令</title>
    <link href="https://www.tinydolphin.cn/2018/09/10/%E5%B7%A5%E5%85%B7/Mac%E7%BB%88%E7%AB%AF%E6%B7%BB%E5%8A%A0ll%E3%80%81la%E3%80%81l%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.tinydolphin.cn/2018/09/10/工具/Mac终端添加ll、la、l命令/</id>
    <published>2018-09-10T15:40:23.000Z</published>
    <updated>2018-10-28T13:50:09.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac终端添加ll、la、l命令u"><a href="#Mac终端添加ll、la、l命令u" class="headerlink" title="Mac终端添加ll、la、l命令u"></a>Mac终端添加ll、la、l命令u</h1><h3 id="NO-1-编辑-bash-profile文件"><a href="#NO-1-编辑-bash-profile文件" class="headerlink" title="NO.1 编辑.bash_profile文件"></a>NO.1 编辑.bash_profile文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="NO-2-添加别名映射关系"><a href="#NO-2-添加别名映射关系" class="headerlink" title="NO.2 添加别名映射关系"></a>NO.2 添加别名映射关系</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias ll='ls -alF'</span><br><span class="line">alias la='ls -A'</span><br><span class="line">alias l='ls -CF'</span><br></pre></td></tr></table></figure><h3 id="NO-3-source-文件"><a href="#NO-3-source-文件" class="headerlink" title="NO.3 source 文件"></a>NO.3 source 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="https://www.tinydolphin.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac如何重置root用户密码</title>
    <link href="https://www.tinydolphin.cn/2018/09/10/%E5%B7%A5%E5%85%B7/Mac%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEroot%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
    <id>https://www.tinydolphin.cn/2018/09/10/工具/Mac如何重置root用户密码/</id>
    <published>2018-09-10T15:30:23.000Z</published>
    <updated>2018-10-28T13:50:05.178Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac如何重置root用户密码？"><a href="#Mac如何重置root用户密码？" class="headerlink" title="Mac如何重置root用户密码？"></a>Mac如何重置root用户密码？</h1><p>1、打开终端，输入：sudo bash，提示输入当前用户密码</p><p>2、成功进入bash命令模式之后，输入 sudo passwd root</p><p>3、输入新的 root 密码即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="https://www.tinydolphin.cn/tags/Mac/"/>
    
  </entry>
  
</feed>
