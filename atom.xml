<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TinyDolphin&#39;s Blog</title>
  
  <subtitle>不忘初心, 方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.tinydolphin.cn/"/>
  <updated>2018-11-04T03:29:02.004Z</updated>
  <id>https://www.tinydolphin.cn/</id>
  
  <author>
    <name>TinyDolphin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初次使用 Celery</title>
    <link href="https://www.tinydolphin.cn/2018/11/04/Celery/%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%20Celery/"/>
    <id>https://www.tinydolphin.cn/2018/11/04/Celery/初次使用 Celery/</id>
    <published>2018-11-04T03:18:25.000Z</published>
    <updated>2018-11-04T03:29:02.004Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="初次使用-Celery"><a href="#初次使用-Celery" class="headerlink" title="初次使用 Celery"></a>初次使用 Celery</h1><ul><li>选择并安装一个消息传输者（broker）</li><li>安装 Celery 并创建第一个task</li><li>启动 worker 并调用task</li><li>在任务转换到不同状态时跟踪任务，并检查返回值</li></ul><h3 id="NO-1-选择一个-Broker"><a href="#NO-1-选择一个-Broker" class="headerlink" title="NO.1 选择一个 Broker"></a>NO.1 选择一个 Broker</h3><p>①、RabbitMQ功能齐全，稳定，耐用且易于安装。它是生产环境的绝佳选择。（官网推荐使用）</p><p>②、Redis功能齐全，但在突然终止或电源故障时更容易丢失数据</p><h3 id="NO-2-安装-Celery"><a href="#NO-2-安装-Celery" class="headerlink" title="NO.2 安装 Celery"></a>NO.2 安装 Celery</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install celery</span><br></pre></td></tr></table></figure><h3 id="NO-3-应用"><a href="#NO-3-应用" class="headerlink" title="NO.3 应用"></a>NO.3 应用</h3><p>首先，需要一个 <strong>Celery 实例</strong>（称为 Celery application 或者 <em>app</em>），其作用：在 Celery 中执行的所有操作（创建任务 / 管理工作程序）的<strong>入口点</strong>。因此其他模板必须导入它。</p><p>①、创建 Celery 实例（app）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Celery 实例</span></span><br><span class="line"><span class="comment"># 第一个参数：当前模板的名称。只有在 __main__ 模板中定义任务时才能自动生成名称。</span></span><br><span class="line"><span class="comment"># 第二个参数：指定使用的消息代理的 URL</span></span><br><span class="line">app = Celery(<span class="string">'tasks'</span>, broker=<span class="string">'pyamqp://guest@localhost//'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为 add 的单个任务：返回两个数的总和</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p>②、运行 celery worker server<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动 worker</span><br><span class="line">celery -A tasks worker --loglevel=info</span><br><span class="line"><span class="meta">#</span> 帮助指令</span><br><span class="line">celery worker --help</span><br><span class="line">celery help</span><br></pre></td></tr></table></figure></p><p>③、调用 task<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 开始编写 python 代码</span><br><span class="line">from tasks import add</span><br><span class="line"><span class="meta">#</span> 可以使用 delay() 方法来调用我们的任务，由我们的 celery worker 执行</span><br><span class="line">add.delay(4, 4) </span><br><span class="line"><span class="meta">#</span> 返回 AsyncResult 实例，可用于检查任务的状态，等待任务完成或获取返回值（如果任务失败，则为异常和回溯）</span><br></pre></td></tr></table></figure></p><p>④、保存结果</p><p>默认情况下，不保存结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 redis 作为结果后端</span></span><br><span class="line">app = Celery(<span class="string">'tasks'</span>,brackend=<span class="string">'redis://localhost'</span>, broker=<span class="string">'pyamqp://'</span>)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">result = add.delay(<span class="number">4</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 查看任务是否完成处理</span></span><br><span class="line">result.ready()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以等待任务完成，但这很少使用，因为它把异步调用变成了同步调用</span></span><br><span class="line">result.get(timeout=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 倘若任务抛出了一个异常， get() 会重新抛出异常， 但你可以指定 propagate 参数来覆盖这一行为:</span></span><br><span class="line">result.get(propagate=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果任务抛出了一个异常，你也可以获取原始的回溯信息</span></span><br><span class="line">result.traceback</span><br></pre></td></tr></table></figure><p>⑤、配置</p><p>在较大的项目中，采用独立配置模块（<strong>中心化保存配置</strong>）更为有效。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让 Celery 实例加载配置模板</span></span><br><span class="line">app.config_from_object(<span class="string">'celeryconfig'</span>)</span><br></pre></td></tr></table></figure></p><p>celeryconfig.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BROKER_URL = <span class="string">'amqp://'</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'amqp://'</span></span><br><span class="line">CELERY_TASK_SERIALIZER = <span class="string">'json'</span></span><br><span class="line">CELERY_RESULT_SERIALIZER = <span class="string">'json'</span></span><br><span class="line">CELERY_ACCEPT_CONTENT=[<span class="string">'json'</span>]</span><br><span class="line">CELERY_TIMEZONE = <span class="string">'Europe/Oslo'</span></span><br><span class="line">CELERY_ENABLE_UTC = <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>验证你的配置文件可以正确工作，且不包含语法错误<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m celeryconfig # 不报错，即通过</span><br></pre></td></tr></table></figure></p><p>要证明配置文件的强大，我们可以把<strong>不同的任务路由到专用的队列</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CELERY_ROUTES = &#123;</span><br><span class="line">    <span class="string">'tasks.add'</span>: <span class="string">'low-priority'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者，你可以<strong>限制任务的速率</strong>，这样每分钟只允许处理 10 个该类型的任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CELERY_ANNOTATIONS = &#123;</span><br><span class="line">    <span class="string">'tasks.add'</span>: &#123;<span class="string">'rate_limit'</span>: <span class="string">'10/m'</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你使用 RabbitMQ 或 Redis 作为中间人，那么你也可以在运行时直接在<strong>职程上设置速率限制</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery control rate_limit tasks.add 10/m</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="python" scheme="https://www.tinydolphin.cn/tags/python/"/>
    
      <category term="分布式任务队列" scheme="https://www.tinydolphin.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to Celery</title>
    <link href="https://www.tinydolphin.cn/2018/11/04/Celery/Introduction%20to%20Celery/"/>
    <id>https://www.tinydolphin.cn/2018/11/04/Celery/Introduction to Celery/</id>
    <published>2018-11-04T02:18:25.000Z</published>
    <updated>2018-11-04T02:46:20.050Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Introduction-to-Celery"><a href="#Introduction-to-Celery" class="headerlink" title="Introduction to Celery"></a>Introduction to Celery</h1><h2 id="什么是任务队列？"><a href="#什么是任务队列？" class="headerlink" title="什么是任务队列？"></a>什么是任务队列？</h2><p>它是一种在线程或者机器之间分发任务的机制、一种专注于实时处理和任务调度的分布式任务队列</p><p>它的输入：任务（工作的一个单元），专用的worker进程会持续的监控任务队列中是否有需要处理的新任务。</p><p>Celery 通过<strong>消息</strong>进行通信，经常使用中间人（Broker）在 client &amp; worker 之间进行调度（消息传输）。</p><p>一个 Celery 可以由多个 <strong>worker</strong> 和 <strong>broker</strong> 组成，以此来获得高可用性和横向扩展能力。</p><p>Celery 是用 Python 写的，但协议可以用任何语言实现。</p><h2 id="需要做什么？"><a href="#需要做什么？" class="headerlink" title="需要做什么？"></a>需要做什么？</h2><p>Celery 需要一个<strong>发送和接收消息的传输者</strong>。<strong>RabbitMQ</strong> &amp; <strong>Redis</strong> 作为中间人 <strong>Broker</strong>，支持所有的特性。还提供其他的支持，如：SQLite</p><p>Celery 可以<strong>单机运行</strong>，也可以在<strong>多台机器</strong>运行，甚至可以<strong>跨越数据中心</strong>运行。</p><h2 id="Celery-是…的"><a href="#Celery-是…的" class="headerlink" title="Celery 是…的"></a>Celery 是…的</h2><ul><li><p><strong>简单</strong></p><ul><li>易于使用和维护，<strong>不需要配置文件</strong></li><li>一个最简单的应用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line">app = Celery(&apos;hello&apos;, broker=&apos;amqp://guest@localhost//&apos;)</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def hello():</span><br><span class="line">    return &apos;hello world&apos;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>高可用性</strong></p><ul><li>当链接丢失或者失败的时候，workers &amp; clients 将会自动重试，并且一些 breakers 会通过 主/主 或者 主/副 复制的方式来提高可用性</li></ul></li><li><p><strong>快速</strong></p><ul><li>单个 Celery 进程每分钟可处理数以百万计的任务，而保持往返延迟在亚毫秒级。（使用 RabbitMQ、py-librabbitmq 和优化过的设置）</li></ul></li><li><p><strong>灵活</strong></p><ul><li>Celery 几乎每个部分都可以自行扩展或使用。如：自制连接池、 序列化、压缩模式、日志、调度器、消费者、生产者、自动扩展、 中间人传输或更多</li></ul></li></ul><p><strong>它支持的</strong></p><ul><li>Breakers 中间人：RabbitMQ、Redis、Amazon SQS and more</li><li>Concurrency 并发：prefork (multiprocessing：多进程)、Eventlet、gevent、solo (single threaded)多线程/单线程</li><li>Result Stores 结果存储：AMQP、Redis、Memcached、SQLAlchemy、Django ORM、Apache Cassandra、Elasticsearch</li><li>Serialization 序列化：pickle、json、yaml、msgpack、zlib、bzip2 compression、Cryptographic message signing</li></ul><h2 id="Celery-特性（略）"><a href="#Celery-特性（略）" class="headerlink" title="Celery 特性（略）"></a>Celery 特性（略）</h2><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>例子一：在程序的运行过程中，经常会碰到一些耗时耗资源的操作，为了避免它们阻塞主程序的运行，我们经常会采用多线程或异步任务。</strong></p><p>比如：在 web 开发中，对新用户的注册，我们通常会给他发一封激活邮件，而发邮件就是 IO阻塞式任务，如果它们直接放到应用当中，就需要等到邮件发出去之后，才能进行下一步操作，此时用户只有一直等待。</p><p>celery 解决方案：在业务逻辑中<strong>触发一个发邮件的异步任务</strong>，而主程序可以继续往下运行。</p><p><strong>例子二：在程序运行的过程中，有一个要运行很久的任务，但是我们又不想阻塞主程序</strong>。</p><ol><li>解决方案：使用多线程。但是当<strong>并发量过大</strong>时，多线程也会扛不住</li><li>继续解决：使用线程池来限制并发数。<ul><li>多线程对于<strong>共享资源</strong>的使用也是比较麻烦的一件事。</li><li>对于<strong>协程</strong>，它还是在同一个线程中执行的，如果一个任务本身的执行时间很长，而不是因为等待 IO 被挂起的，那么也同样会阻塞其他的协程。</li></ul></li><li>最终方案：基于以上的问题，我们可以使用一个强大的分布式任务队列 Celery 来<strong>让任务的执行和主程序完全的脱离</strong>，甚至不在同一个主机内。通过<strong>队列</strong>来调度任务，所以不用担心并发量高时导致系统负载过大。</li></ol><p><strong>例子三：执行和主程序脱离</strong></p><p>你想对100台机器执行一条批量命令，可能会花很长时间 ，但你不想让你的程序等着结果返回，而是给你返回一个任务ID,你过一段时间只需要拿着这个任务id就可以拿到任务执行结果，这样的话，在任务执行进行时，你可以继续做其它的事情。</p><p><strong>例子四：做一个定时任务</strong></p><p>比如每天定时检测一下你们所有客户的资料，如果发现今天是客户的生日，就给他发个短信祝福</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="python" scheme="https://www.tinydolphin.cn/tags/python/"/>
    
      <category term="分布式任务队列" scheme="https://www.tinydolphin.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</title>
    <link href="https://www.tinydolphin.cn/2018/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%B5%85%E6%9E%90%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E3%80%81%E5%B9%B3%E5%9D%87%E3%80%81%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://www.tinydolphin.cn/2018/10/28/数据结构与算法/复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度/</id>
    <published>2018-10-28T14:45:33.000Z</published>
    <updated>2018-10-28T13:51:56.296Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"><a href="#复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"></a>复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</h1><p>主要四个复杂度分析方面的知识点：<strong>最好情况时间复杂度</strong>、<strong>最坏情况时间复杂度</strong>、<strong>平均情况时间复杂度</strong>、<strong>均摊时间复杂度</strong></p><h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，我们上一节简单的分析方法，解决不了这个问题。</p><p>第一种情况：如果数组中第一个元素正好是要查找的变量 x ，那么就不需要继续遍历剩下的 n - 1 个数据了，那么时间复杂度：O(1)</p><p>第二种情况：如果数组中不存在要查找的变量 x ，那就需要把整个数组都遍历一遍，时间复杂度就成了：O(n)</p><p>所以：不同的情况下，这段代码的复杂度不一样。</p><p>①、<strong>最好情况时间复杂度</strong>就是，在<strong>最理想</strong>的情况下，执行这段代码的时间复杂度。</p><p>②、<strong>最坏情况时间复杂度</strong>就是，在<strong>最糟糕</strong>的情况下，执行这段代码的时间复杂度。</p><h2 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h2><h3 id="不考虑变量-x-在数组中出现的概率问题（结论正确，但是分析过程有点问题）"><a href="#不考虑变量-x-在数组中出现的概率问题（结论正确，但是分析过程有点问题）" class="headerlink" title="不考虑变量 x 在数组中出现的概率问题（结论正确，但是分析过程有点问题）"></a>不考虑变量 x 在数组中出现的概率问题（结论正确，但是分析过程有点问题）</h3><p>拿上面的代码来分析，要查找变量 x 在数组中的位置，有 n + 1 种情况：<strong>在数组 0 ~ n -1 位置中和不在数组中</strong>。这样的话，我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n + 1 ，就可以得到需要遍历的元素个数的平均值了，即：(1 + 2 + 3 …… + n + n ) / (n+1) = n(n+3) / 2(n+1) 。</p><p>但是在时间复杂度大 O 标记法中，可以省略掉系数、低阶、常量，所以简化之后，得到的平均时间复杂度就是 O(n)。</p><h3 id="考虑变量-x-在数组中出现的概率问题"><a href="#考虑变量-x-在数组中出现的概率问题" class="headerlink" title="考虑变量 x 在数组中出现的概率问题"></a>考虑变量 x 在数组中出现的概率问题</h3><p>为了方便理解，我们假设在数组中和不在数组中的概率都为 1/2 。要查找的数据出现在 0 ~ n-1 这 n 个位置的概率也是一样的，为 1/n 。所以，根据概率乘法法则，要查找的元素出现在 0 ~ n-1 中任意位置的概率为 1/(2n)。</p><p>那么考虑概率的话，计算过程：1 <em> 1/(2n) + 2 </em> 1/(2n) + 3 <em> 1/(2n) + …… + n </em> 1/(2n) + n * 1/2 = (1+3n)/4 ，用大 O 表示法来表示，这段代码的加权平均时间复杂度仍然是 O(n) 。</p><p>这个值就是概率论中的<strong>加权平均值</strong>，也叫做<strong>期望值</strong>，所以<strong>平均时间复杂度</strong>的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p><h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现的功能：往数组中插入数据。当数组满了之后，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，再将新的数据插入。</span></span><br><span class="line"><span class="comment">// array 表示一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == <span class="built_in">array</span>.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; ++i) &#123;</span><br><span class="line">         sum = sum + <span class="built_in">array</span>[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">array</span>[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">array</span>[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用之前的方式去分析时间复杂度"><a href="#利用之前的方式去分析时间复杂度" class="headerlink" title="利用之前的方式去分析时间复杂度"></a>利用之前的方式去分析时间复杂度</h3><p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置即可，所以最好情况时间复杂度为 O(1)。</p><p>最坏的情况下，数组中没有空闲空间，我们需要做一次数组遍历求和，然后再将数据插入，所以最坏的情况为 O(n) </p><p>平均时间复杂度下，根据数据插入的位置不同，我们可以分为 n 种情况，每种情况的时间复杂度为 O(1) 。除此之外，还有一种”额外”的情况，就是在数组没有空闲空间的插入一个数据时，时间复杂度为 O(n)，而且这 n + 1 种情况发生的概率一样，都是 1/(n+1) 。所以，根据加权平均的计算方法，我们可以得到平均时间复杂度：1 <em> 1/(n+1) + 1 </em> 1/(n+1) + 1 <em> 1/(n+1) …… 1 </em> 1/(n+1) + n * 1/(n+1) = 2n/(n+1) —&gt; O(1) </p><h3 id="利用摊还分析法去分析时间复杂度"><a href="#利用摊还分析法去分析时间复杂度" class="headerlink" title="利用摊还分析法去分析时间复杂度"></a>利用摊还分析法去分析时间复杂度</h3><p><strong>①、首先来看看 insert() 与 find() 的区别：</strong></p><ul><li>find() 函数在极端的情况下，复杂度才为 O(1) ，但 <strong>insert() 在大多数情况下，时间复杂度都为 O(1)</strong>，只有个别情况下，复杂度才为 O (n) ；</li><li>对于 insert() 函数来说，O(1) 时间复杂度的插入和O(n) 时间复杂度的插入，出现的频率非常的有规律，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟 n-1 个O(1) 的插入操作，循环往复。 </li></ul><p>基于以上两种不同，我们可以引入一种更加简单的分析方法：摊还分析法。通过这种方法得到的时间复杂度，就叫做：<strong>均摊时间复杂度</strong>。</p><p><strong>②、如何使用摊还分析法来分析算法的均摊时间复杂度</strong></p><p>大致思路：每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时小的操作上，均摊下来，这一组的连续的操作的均摊时间复杂度就是 O(1) 。</p><p>均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。其实<strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>对一个数据结构进行一组连续的操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块分析，看是否能够将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且这种情况下，一般均摊时间复杂度就等于最好情况时间复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.tinydolphin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://www.tinydolphin.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://www.tinydolphin.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</title>
    <link href="https://www.tinydolphin.cn/2018/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%EF%BC%9F/"/>
    <id>https://www.tinydolphin.cn/2018/10/28/数据结构与算法/复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？/</id>
    <published>2018-10-28T12:25:35.000Z</published>
    <updated>2018-10-28T14:03:35.570Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"><a href="#复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？" class="headerlink" title="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"></a>复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</h1><p><strong>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半</strong></p><blockquote><p><strong>Q：为什么需要复杂度分析？</strong></p><p>A：首页对于这个问题有所疑惑：明明可以把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小（某些书中的”事后统计法”）。为什么还需要复杂度分析呢？</p><p>因为这种方法存在很大的<strong>局限性</strong>：</p><p>①、<strong>测试结果非常的依赖测试环境</strong><br><br>    不同的测试环境，得到的结果可能完全不同。</p><p>②、<strong>测试结果受数据规模的影响很大</strong><br><br>    比如：排序算法中，对于不一样的待排序数据有序度，排序的执行时间就有很大的差别。（对于小规模的数据排序，插入排序可能反倒会比快速排序要快！）</p><p>所以，我们需要一个<strong>不用具体的测试数据来测试</strong>，就可以<strong>粗略地估算出算法的执行效率</strong>的方法——<strong>时间、空间复杂度分析</strong>。</p></blockquote><h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2><p>我们假设每一段代码的执行时间为 t</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;             <span class="comment">// 一个 t 的执行时间 </span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;               <span class="comment">// t</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;    <span class="comment">// n * t</span></span><br><span class="line">    sum = sum + i;         <span class="comment">// n * t</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 所以这段代码的总的执行时间 T(n) = (2n+2)*t 。可以看出：<strong>总的代码执行时间 T(n) 与每行代码的执行次数成正比</strong>。</p><p>所以，这段代码的大 O 时间复杂度表示法： <strong>T(n) = O(f(n))</strong></p><p>其中：T(n)：代码总的执行时间、n：数据规模的大小、f(n) 每行代码执行的次数总和、O ：代码的执行时间 T(n) 与 f(n) 表达式成正比</p><p>大 O 时间复杂度表示法：并不具体表示代码的真正执行时间，而是表示<strong>代码执行时间随着数据规模增长的变化趋势</strong>。也叫 <strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong></p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="1、只关注循环执行次数最大的一段代码"><a href="#1、只关注循环执行次数最大的一段代码" class="headerlink" title="1、只关注循环执行次数最大的一段代码"></a>1、只关注循环执行次数最大的一段代码</h3><p>既然说大 O 复杂度是一种变化趋势，那么我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">// 常量级别的执行时间，与 n 无关，可以忽略</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">// 同上</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;<span class="comment">// n</span></span><br><span class="line">    sum = sum + i;<span class="comment">// n</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以以上代码，总的时间复杂度：O(n)</p><h3 id="2、加法规则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2、加法规则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2、加法规则：总复杂度等于量级最大的那段代码的复杂度"></a>2、加法规则：总复杂度等于量级最大的那段代码的复杂度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">true<span class="comment">// 常量级别</span></span><br><span class="line">   <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line">true<span class="comment">// O(n) 级别</span></span><br><span class="line">   <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// O(n²) 级别</span></span><br><span class="line">   <span class="keyword">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以以上代码，总的时间复杂度：T(n) = T1(n) + T2(n) + T3(n) = O(1) + O(n) + O(n²) = O(n²) </p><p>如果 T1(n) = O(f(n))、T2(n) = O(g(n))；那么T(n) = T1(n) + T2(n) = Max(O(f(n),  g(n)))</p><h3 id="3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">true<span class="comment">// O(n) 级别</span></span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// O(n) 级别</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以以上代码，总的时间复杂度：T = T1(n) <em> T2(n) = O(n </em> n) = O(n²) </p><p>如果 T1(n) = O(f(n))、T2(n) = O(g(n))；那么T(n) = T1(n) <em> T2(n) = O(f(n) </em> g(n))</p><h2 id="几种常见的时间复杂度实例分析"><a href="#几种常见的时间复杂度实例分析" class="headerlink" title="几种常见的时间复杂度实例分析"></a>几种常见的时间复杂度实例分析</h2><h3 id="1、多项式时间复杂度"><a href="#1、多项式时间复杂度" class="headerlink" title="1、多项式时间复杂度"></a>1、多项式时间复杂度</h3><p>常量阶 O(1)、对数阶 O(logn)、线性阶 O(n)、线性对数阶 O(nlogn)、平方阶 O(n²)、立方阶 O(n³) …… K方阶 O(n^k)</p><h4 id="①、O-1"><a href="#①、O-1" class="headerlink" title="①、O(1)"></a>①、O(1)</h4><p>一般情况下，只要算法中不存在循环语句，递归语句，就算有成千上万行代码，其时间复杂度依然是 O(1)</p><h4 id="②、O-logn、nlogn"><a href="#②、O-logn、nlogn" class="headerlink" title="②、O(logn、nlogn)"></a>②、O(logn、nlogn)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设第三行代码的执行次数为 x ，则可以得到 2^x = n，进而得到 x = log2(n) 。所以这段代码的时间复杂度为 O(log2(n))。</p><p>由于前面我们说过，<strong>在使用大O标记复杂度的时候，可以忽略系数</strong>。所以，在对数阶时间复杂度的时候，我们忽略对数的底，统一表示为 O(logn)</p><h4 id="③、O-n-m-、O-n-m"><a href="#③、O-n-m-、O-n-m" class="headerlink" title="③、O(n+m)、O(n*m)"></a>③、O(n+m)、O(n*m)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，出现两个无法预知 n、m 的数据规模量级大小，所以不能简单的利用加法法则，省略掉其中一个。所以以上代码的时间复杂度：T1(n) + T1(m) = O(f(n) + g(m)) = O(n+m)。</p><p>虽然此时加法法则无效，但是乘法法则依然有效：T1(n) <em> T2(m) = O(f(n) </em> g(m))  = O(n * m)</p><h3 id="2、非多项式时间复杂度（非常低效的方法，直接略）"><a href="#2、非多项式时间复杂度（非常低效的方法，直接略）" class="headerlink" title="2、非多项式时间复杂度（非常低效的方法，直接略）"></a>2、非多项式时间复杂度（非常低效的方法，直接略）</h3><p>指数阶 O(2^n)、阶乘阶 O(n!) 。</p><p>对于这个时间复杂度，会随着数据规模的增长，算法的执行时间会急剧增加。所以非常的低效。</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>前面讲过，时间复杂度的全称是<strong>渐进时间复杂度</strong>，表示<strong>算法的执行时间与数据规模之间的增长关系</strong>。那么类比一下，<strong>空间复杂度</strong>就是<strong>渐进空间复杂度</strong>，表示<strong>算法的存储空间与数据规模之间的增长关系</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 常量阶，申请了一个空间存储变量 i</span></span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">// 一个大小为 n 的 int 型数组</span></span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，以上的空间复杂度：O(n) </p><p>常见的空间复杂度：O(1)、O(n)、O(n²)，像 O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都要分析一下时间复杂度、空间复杂度是不是很浪费时间呢？你怎么看待这个问题呢？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://www.tinydolphin.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://www.tinydolphin.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="https://www.tinydolphin.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装 brew 以及部分使用指令</title>
    <link href="https://www.tinydolphin.cn/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20%20brew%20%E4%BB%A5%E5%8F%8A%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <id>https://www.tinydolphin.cn/2018/09/17/工具/Mac 安装  brew 以及部分使用指令/</id>
    <published>2018-09-17T15:22:54.000Z</published>
    <updated>2018-10-28T13:49:54.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-安装-brew-以及部分使用指令"><a href="#Mac-安装-brew-以及部分使用指令" class="headerlink" title="Mac 安装 brew 以及部分使用指令"></a>Mac 安装 brew 以及部分使用指令</h1><h3 id="NO-1-官网获取下载指令"><a href="#NO-1-官网获取下载指令" class="headerlink" title="NO.1 官网获取下载指令"></a>NO.1 官网获取下载指令</h3><p><a href="http://brew.sh/" target="_blank" rel="noopener">http://brew.sh/</a></p><p>Homebrew安装成功后，会自动创建目录 /usr/local/Cellar 来存放Homebrew安装的程序</p><h3 id="NO-2-使用-brew"><a href="#NO-2-使用-brew" class="headerlink" title="NO.2 使用 brew"></a>NO.2 使用 brew</h3><ul><li>安装软件：brew install 软件名，例：brew install wget</li><li>搜索软件：brew search 软件名，例：brew search wget</li><li>卸载软件：brew uninstall 软件名，例：brew uninstall wget</li><li>更新所有软件：brew update</li><li>更新具体软件：brew upgrade 软件名 ，例：brew upgrade git</li><li>显示已安装软件：brew list</li><li>查看软件信息：brew info／home 软件名 ，例：brew info git ／ brew home git<br>PS：brew home指令是用浏览器打开官方网页查看软件信息</li><li>查看哪些已安装的程序需要更新： brew outdated</li><li>显示包依赖：brew reps</li><li>显示帮助：brew help</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="https://www.tinydolphin.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装 Redis</title>
    <link href="https://www.tinydolphin.cn/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Redis/"/>
    <id>https://www.tinydolphin.cn/2018/09/17/工具/Mac 安装 Redis/</id>
    <published>2018-09-17T15:22:54.000Z</published>
    <updated>2018-10-30T02:58:50.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-安装-Redis"><a href="#Mac-安装-Redis" class="headerlink" title="Mac 安装 Redis"></a>Mac 安装 Redis</h1><h3 id="NO-1-Mac-下安装-Redis"><a href="#NO-1-Mac-下安装-Redis" class="headerlink" title="NO.1 Mac 下安装 Redis"></a>NO.1 Mac 下安装 Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure><h3 id="NO-2-启动-amp-停止-Rabbitmq"><a href="#NO-2-启动-amp-停止-Rabbitmq" class="headerlink" title="NO.2 启动 &amp; 停止 Rabbitmq"></a>NO.2 启动 &amp; 停止 Rabbitmq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动Redis服务</span><br><span class="line">brew services start redis</span><br><span class="line"><span class="meta">#</span> 关闭Redis服务</span><br><span class="line">brew services stop redis</span><br><span class="line"><span class="meta">#</span> 重启Redis服务</span><br><span class="line">brew services restart redis</span><br><span class="line"><span class="meta">#</span> 打开图形化界面</span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure><h3 id="NO-3-redise的配置文件所在路径"><a href="#NO-3-redise的配置文件所在路径" class="headerlink" title="NO.3 redise的配置文件所在路径"></a>NO.3 redise的配置文件所在路径</h3><p>/usr/local/etc/redis.conf</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Redis" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/Redis/"/>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/Redis/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="https://www.tinydolphin.cn/tags/Mac/"/>
    
      <category term="Redis" scheme="https://www.tinydolphin.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装 Rabbitmq</title>
    <link href="https://www.tinydolphin.cn/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Rabbitmq/"/>
    <id>https://www.tinydolphin.cn/2018/09/17/工具/Mac 安装 Rabbitmq/</id>
    <published>2018-09-17T15:22:54.000Z</published>
    <updated>2018-10-28T13:49:59.500Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-安装-Rabbitmq"><a href="#Mac-安装-Rabbitmq" class="headerlink" title="Mac 安装 Rabbitmq"></a>Mac 安装 Rabbitmq</h1><h3 id="NO-1-Mac-下安装-Rabbitmq"><a href="#NO-1-Mac-下安装-Rabbitmq" class="headerlink" title="NO.1 Mac 下安装 Rabbitmq"></a>NO.1 Mac 下安装 Rabbitmq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" # 安装 brew（Homebrew：Mac OS平台下的软件包管理工具）</span><br><span class="line">brew install rabbitmq</span><br><span class="line">sudo vim ~/.bash_profile</span><br><span class="line">PATH=$PATH:/usr/local/sbin # 最后一行加上</span><br></pre></td></tr></table></figure><h3 id="NO-2-启动-amp-停止-Rabbitmq"><a href="#NO-2-启动-amp-停止-Rabbitmq" class="headerlink" title="NO.2 启动 &amp; 停止 Rabbitmq"></a>NO.2 启动 &amp; 停止 Rabbitmq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动服务</span><br><span class="line">brew services start rabbitmq</span><br><span class="line"><span class="meta">#</span> 停止服务</span><br><span class="line">brew services stop rabbitmq</span><br><span class="line"><span class="meta">#</span> 启用插件</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"><span class="meta">#</span> 禁用插件</span><br><span class="line">rabbitmq-plugins disable rabbitmq_management</span><br></pre></td></tr></table></figure><h3 id="NO-3-进入控制台"><a href="#NO-3-进入控制台" class="headerlink" title="NO.3 进入控制台"></a>NO.3 进入控制台</h3><p><a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p><p>默认用户名和密码：guest , guest</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Rabbitmq" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/Rabbitmq/"/>
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/Rabbitmq/Celery/"/>
    
    
      <category term="Celery" scheme="https://www.tinydolphin.cn/tags/Celery/"/>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="https://www.tinydolphin.cn/tags/Mac/"/>
    
      <category term="Rabbitmq" scheme="https://www.tinydolphin.cn/tags/Rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>POJ 1852 Ants</title>
    <link href="https://www.tinydolphin.cn/2018/09/15/ACM/POJ/1852/"/>
    <id>https://www.tinydolphin.cn/2018/09/15/ACM/POJ/1852/</id>
    <published>2018-09-15T14:45:33.000Z</published>
    <updated>2018-10-28T13:50:19.535Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="POJ-1852-Ants"><a href="#POJ-1852-Ants" class="headerlink" title="POJ 1852 Ants"></a>POJ 1852 Ants</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    POJ:1852</span></span><br><span class="line"><span class="comment">    题意：简单的理解就是， N 只蚂蚁以 1cm/s 的速度在，一条长 L 厘米的竿子上爬行（不知道初始的爬行方向），当蚂蚁爬到竿子的端点时会掉落。</span></span><br><span class="line"><span class="comment">        但竿子太细了，如果有两只蚂蚁相遇时，它们只能各自反向爬回去。</span></span><br><span class="line"><span class="comment">        对于蚂蚁，我们只知道它们距离竿子左端的距离 xi，但不知道当前蚂蚁的朝向</span></span><br><span class="line"><span class="comment">        请计算所有蚂蚁落下竿子所需要的最短时间和最长时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    迷惑条件：如果有两只蚂蚁相遇时，它们只能各自反向爬回去。</span></span><br><span class="line"><span class="comment">    转换思路：其实不管相遇后各自反向爬 OR 相遇后保持原方向爬行，结果都是一样的。</span></span><br><span class="line"><span class="comment">    这样的话，最短时间 = MAX（所有蚂蚁距离竿子端点的最近距离）</span></span><br><span class="line"><span class="comment">            最长时间 = MAX（所有蚂蚁距离竿子端点的最远距离）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000010 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,l,x[MAX_N];</span><br><span class="line"><span class="keyword">int</span> maxT, minT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    minT = <span class="number">0</span>;</span><br><span class="line">    maxT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">        minT = max(minT, min(x[i], l - x[i]));</span><br><span class="line">        maxT = max(maxT, max(x[i], l - x[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l , &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, minT, maxT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="ACM" scheme="https://www.tinydolphin.cn/categories/ACM/"/>
    
    
      <category term="ACM" scheme="https://www.tinydolphin.cn/tags/ACM/"/>
    
      <category term="POJ" scheme="https://www.tinydolphin.cn/tags/POJ/"/>
    
      <category term="C++" scheme="https://www.tinydolphin.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>JetBrains系开发工具激活</title>
    <link href="https://www.tinydolphin.cn/2018/09/11/%E5%B7%A5%E5%85%B7/JetBrains%E7%B3%BB%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%BF%80%E6%B4%BB/"/>
    <id>https://www.tinydolphin.cn/2018/09/11/工具/JetBrains系开发工具激活/</id>
    <published>2018-09-11T01:06:23.000Z</published>
    <updated>2018-10-28T13:49:49.426Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>NO.1</strong></p><p>将“0.0.0.0 account.jetbrains.com”添加到 <strong>hosts 文件末尾处</strong></p><p>hosts 文件所在目录：</p><ul><li><p>Windows：C:\Windows\System32\drivers\etc\hosts</p></li><li><p>Mac：/etc/hosts</p></li></ul><p><strong>NO.2</strong></p><p>进入 <a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a> ，获得注册码即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Mac终端添加ll、la、l命令</title>
    <link href="https://www.tinydolphin.cn/2018/09/10/%E5%B7%A5%E5%85%B7/Mac%E7%BB%88%E7%AB%AF%E6%B7%BB%E5%8A%A0ll%E3%80%81la%E3%80%81l%E5%91%BD%E4%BB%A4/"/>
    <id>https://www.tinydolphin.cn/2018/09/10/工具/Mac终端添加ll、la、l命令/</id>
    <published>2018-09-10T15:40:23.000Z</published>
    <updated>2018-10-28T13:50:09.249Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac终端添加ll、la、l命令u"><a href="#Mac终端添加ll、la、l命令u" class="headerlink" title="Mac终端添加ll、la、l命令u"></a>Mac终端添加ll、la、l命令u</h1><h3 id="NO-1-编辑-bash-profile文件"><a href="#NO-1-编辑-bash-profile文件" class="headerlink" title="NO.1 编辑.bash_profile文件"></a>NO.1 编辑.bash_profile文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="NO-2-添加别名映射关系"><a href="#NO-2-添加别名映射关系" class="headerlink" title="NO.2 添加别名映射关系"></a>NO.2 添加别名映射关系</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias ll='ls -alF'</span><br><span class="line">alias la='ls -A'</span><br><span class="line">alias l='ls -CF'</span><br></pre></td></tr></table></figure><h3 id="NO-3-source-文件"><a href="#NO-3-source-文件" class="headerlink" title="NO.3 source 文件"></a>NO.3 source 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="https://www.tinydolphin.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Mac如何重置root用户密码</title>
    <link href="https://www.tinydolphin.cn/2018/09/10/%E5%B7%A5%E5%85%B7/Mac%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEroot%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
    <id>https://www.tinydolphin.cn/2018/09/10/工具/Mac如何重置root用户密码/</id>
    <published>2018-09-10T15:30:23.000Z</published>
    <updated>2018-10-28T13:50:05.178Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac如何重置root用户密码？"><a href="#Mac如何重置root用户密码？" class="headerlink" title="Mac如何重置root用户密码？"></a>Mac如何重置root用户密码？</h1><p>1、打开终端，输入：sudo bash，提示输入当前用户密码</p><p>2、成功进入bash命令模式之后，输入 sudo passwd root</p><p>3、输入新的 root 密码即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="工具" scheme="https://www.tinydolphin.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://www.tinydolphin.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Mac" scheme="https://www.tinydolphin.cn/tags/Mac/"/>
    
  </entry>
  
</feed>
