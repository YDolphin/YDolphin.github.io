<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Python 中有关于变量泄露的问题</title>
      <link href="/2019/01/12/Python/Python%20%E4%B8%AD%E6%9C%89%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E6%B3%84%E9%9C%B2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/12/Python/Python%20%E4%B8%AD%E6%9C%89%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E6%B3%84%E9%9C%B2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python-中有关于变量泄露的问题"><a href="#Python-中有关于变量泄露的问题" class="headerlink" title="Python 中有关于变量泄露的问题"></a>Python 中有关于变量泄露的问题</h1><p>环境：Python 2.x<br>语法：<strong>列表推导中 | 生成器表达式 | 集合推导 | 字典推导</strong><br>操作：for 关键词之后的赋值操作<br>影响：上下文中的同名变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.10</span> (default, Aug <span class="number">17</span> <span class="number">2018</span>, <span class="number">19</span>:<span class="number">45</span>:<span class="number">58</span>)</span><br><span class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> Compatible Apple LLVM <span class="number">10.0</span><span class="number">.0</span> (clang<span class="number">-1000.0</span><span class="number">.42</span>)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'123'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">'3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure><p>同样的情况，在 <strong>Python 3.x</strong> 的环境下，不会发生。<br>WHY：Python3 中这些语法都有自己的<strong>局部作用域</strong>，就像函数似的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.7</span><span class="number">.0</span> (default, Sep <span class="number">18</span> <span class="number">2018</span>, <span class="number">18</span>:<span class="number">47</span>:<span class="number">22</span>)</span><br><span class="line">[Clang <span class="number">9.1</span><span class="number">.0</span> (clang<span class="number">-902.0</span><span class="number">.39</span><span class="number">.2</span>)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'123'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="comment"># x 的值被保留了</span></span><br><span class="line"><span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y <span class="comment"># 列表推导也创建了正确的列表</span></span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br></pre></td></tr></table></figure><p>PS：<strong>列表推导</strong>：构建<strong>列表</strong>的快捷方式；<strong>生成器表达式</strong>：创建<strong>其他任何类型的序列</strong>。</p><p>PSS：列表推导 &amp; 生成器表达式 ”<strong>更具可读性</strong>”《fluent python》中推荐使用，使用的原则：<strong>只用列表推导来创建新的列表，并且尽量保持简短，最好不超过两行</strong>。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 变量泄露 </tag>
            
            <tag> 列表推导中 </tag>
            
            <tag> 生成器表达式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 列表推导 &amp; 生成器表达式</title>
      <link href="/2019/01/12/Python/Python%20%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%20&amp;%20%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2019/01/12/Python/Python%20%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%20&amp;%20%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python-列表推导-amp-生成器表达式"><a href="#Python-列表推导-amp-生成器表达式" class="headerlink" title="Python 列表推导 &amp; 生成器表达式"></a>Python 列表推导 &amp; 生成器表达式</h1><p>推荐使用：因为列表推导 &amp; 生成器表达式 ”<strong>更具可读性</strong>”《Fluent Python》中推荐使用，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">'abc'</span></span><br><span class="line">codes = []</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> str:</span><br><span class="line">truecodes.append(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表推导：是不是更具可读性？</span></span><br><span class="line">codes = [s <span class="keyword">for</span> s <span class="keyword">in</span> str]</span><br></pre></td></tr></table></figure><blockquote><p>使用的原则：<strong>只用列表推导来创建新的列表，并且尽量保持简短，最好不超过两行</strong>。</p></blockquote><p><strong>列表推导</strong>：构建<strong>列表</strong>的快捷方式；<strong>生成器表达式</strong>：创建<strong>其他任何类型的序列</strong>。</p><p>语法区别：前者是方括号 “[ ]”，后者是圆括号 ”( )”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">'blank'</span>, <span class="string">'white'</span>]</span><br><span class="line">sizes = [<span class="string">'S'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>]</span><br><span class="line"><span class="comment"># 列表推导</span></span><br><span class="line">tshirt = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes]</span><br><span class="line">type(tshirt) <span class="comment"># list 对象</span></span><br><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line">tshirt = (<span class="string">'%s %s'</span> % (c, s) <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes)</span><br><span class="line">type(tshirt) <span class="comment"># 生成器(Generators)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 生成器表达式 </tag>
            
            <tag> 列表推导 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3网络爬虫工具安装（Mac）</title>
      <link href="/2019/01/12/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%EF%BC%88Mac%EF%BC%89/"/>
      <url>/2019/01/12/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/Python3%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%EF%BC%88Mac%EF%BC%89/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Python3网络爬虫工具安装（Mac）"><a href="#Python3网络爬虫工具安装（Mac）" class="headerlink" title="Python3网络爬虫工具安装（Mac）"></a>Python3网络爬虫工具安装（Mac）</h1><p>以下都是基于 Python3 </p><p>爬虫：抓取页面 -&gt; 分析页面 -&gt; 存储数据</p><h2 id="请求库的安装"><a href="#请求库的安装" class="headerlink" title="请求库的安装"></a>请求库的安装</h2><ul><li><p>Homebrew 安装<br>Mac下的包管理工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</span><br></pre></td></tr></table></figure></li><li><p>Python3 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Python3 &amp; pip3 一起安装</span><br><span class="line">brew install python3</span><br></pre></td></tr></table></figure></li><li><p>requests 安装<br>第三方库，Python不会自带这个库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure></li><li><p>Selenium 安装<br>自动化测试工具，驱动浏览器执行特定的动作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install selenium</span><br></pre></td></tr></table></figure></li><li><p>ChromeDriver 安装<br>自动化测试工具，配置浏览器使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看 chrome 版本以及对应的 chromedriver 版本</span><br><span class="line">http://chromedriver.chromium.org/downloads</span><br><span class="line"><span class="meta">#</span> 配置环境变量</span><br><span class="line">sudo mv chromedriver /usr/local/bin</span><br><span class="line">vim ~/.bash_profile</span><br><span class="line">export PATH=/usr/local/bin:$PATH</span><br><span class="line"><span class="meta">#</span> 使环境变量生效</span><br><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure></li><li><p>aiohttp 安装<br>requests 是一个 ::阻塞式 HTTP 请求库:: ，发出一个请求后，程序会一直等待服务器响应，直到得到响应后，才会进行下一步处理。<br>一个::异步 Web 服务::的库，异步操作可以借助 ::async/await:: 关键字，使写法更简洁。<br>使用场景：<em>维护一个代理池</em>时，利用异步方式检测大量代理的运行状况，会极大地提升效率。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install aiohttp</span><br><span class="line"><span class="meta">#</span> 官方还推荐安装以下两个库：cchardet（字符编码检测库）、aiodns（加速 DNS 的解析库）</span><br><span class="line">pip3 install cchardet aiodns</span><br></pre></td></tr></table></figure></li></ul><h2 id="解析库的安装"><a href="#解析库的安装" class="headerlink" title="解析库的安装"></a>解析库的安装</h2><ul><li><p>lxml 安装<br>Beautiful Soup、Scrapy 框架都需要用到此库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install lxml</span><br><span class="line"><span class="meta">#</span> 如果产生错误，需要先执行以下命令</span><br><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></li><li><p>Beautiful Soup 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip3 install beautifulsoup4</span><br><span class="line"><span class="meta">#</span> 注意导入的时候</span><br><span class="line">from bs4 import BeautifulSoup</span><br></pre></td></tr></table></figure></li><li><p>pyquery 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyquery</span><br></pre></td></tr></table></figure></li><li><p>tesserocr 安装<br>爬虫遇到::验证码::时，可以直接使用 OCR 来识别。（OCR：光学字符识别）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install imagemagick</span><br><span class="line">brew install tesseract --all-languages</span><br><span class="line">pip3 install tesserocr pillow</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据库的安装"><a href="#数据库的安装" class="headerlink" title="数据库的安装"></a>数据库的安装</h2><ul><li><p>MySQL 安装<br>轻量级关系型数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew install mysql</span><br><span class="line">sudo mysql.server start</span><br><span class="line">sudo mysql.server stop</span><br><span class="line">sudo mysql.server restart</span><br></pre></td></tr></table></figure></li><li><p>MongoDB 安装<br>::C++:: 编写的非关系型数据库，基于::分布式文件存储::。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install mongodb</span><br><span class="line">brew services start mongodb</span><br><span class="line">sudo mongod</span><br><span class="line">brew services stop mongodb</span><br><span class="line">brew services restart mongodb</span><br></pre></td></tr></table></figure></li><li><p>Mongo可视化工具<br>RoboMongo/Robo 3T 、Studio 3T</p></li><li><p>Redis 安装<br>基于::内存::的高效的非关系型数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br><span class="line">brew services start redis</span><br><span class="line">redis-server /usr/local/etc/redis.conf</span><br><span class="line">brew services stop redis</span><br><span class="line">brew services restart redis</span><br></pre></td></tr></table></figure></li></ul><h2 id="存储库的安装"><a href="#存储库的安装" class="headerlink" title="存储库的安装"></a>存储库的安装</h2><ul><li><p>PyMySQL 安装<br>为了 Python 与 MySQL 进行交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pymysql</span><br></pre></td></tr></table></figure></li><li><p>PyMongo 安装<br>为了 Python 与 MongoDB 进行交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pymongo</span><br></pre></td></tr></table></figure></li><li><p>redis-py 安装<br>为了 Python 与 redis 进行交互</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install redis</span><br></pre></td></tr></table></figure></li><li><p>RedisDump 安装<br>用于 Redis 数据导入/导出的工具，基于 Ruby 实现的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 需要先安装 Ruby</span><br><span class="line">brew install ruby</span><br><span class="line">gem install redis-dump</span><br></pre></td></tr></table></figure></li></ul><h2 id="Web-库的安装"><a href="#Web-库的安装" class="headerlink" title="Web 库的安装"></a>Web 库的安装</h2><ul><li><p>Flask 安装<br>轻量级的 Web 服务程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install flask</span><br></pre></td></tr></table></figure></li><li><p>Tornado 安装<br>支持::异步::的 Web 框架，通过使用::非阻塞 I/O 流::，可以支撑成千上万的开发连接，效率非常高。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install tornado</span><br></pre></td></tr></table></figure></li></ul><h2 id="App-爬取相关库的安装"><a href="#App-爬取相关库的安装" class="headerlink" title="App 爬取相关库的安装"></a>App 爬取相关库的安装</h2><p>web 网页数据一般是通过请求服务器的接口来获取的，但对于 APP 主要使用一些::抓包技术::来抓取数据。</p><p>抓包工具：<br>Charles &amp; mitmproxy：简单的接口<br>mitmdump：复杂的接口，对抓取的请求和响应进行实时处理和保存<br><em>Appium</em>：像 selenium 一样对 APP 进行自动化控制。</p><ul><li><p>Charles 安装<br>网络抓包工具</p></li><li><p>mitmproxy 安装</p></li><li><p>Appium 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装 node.js </span><br><span class="line">brew install node.js</span><br><span class="line"><span class="meta">#</span> 安装 appium</span><br><span class="line">npm install -g appium</span><br></pre></td></tr></table></figure></li></ul><h2 id="爬虫框架的安装"><a href="#爬虫框架的安装" class="headerlink" title="爬虫框架的安装"></a>爬虫框架的安装</h2><p>requests、selenium 库中的组件是可以复用的，抽离出来，将各个功能模块化，就慢慢形成了爬虫框架。</p><ul><li><p>pyspider 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pyspider</span><br><span class="line"><span class="meta">#</span> Python3.7 把 async 当作关键之，所以需要修改 pyspider 源码中的 aynsc 字段名</span><br><span class="line">pyspider all # 启动</span><br><span class="line"><span class="meta">#</span> 访问 http://localhost:5000/</span><br><span class="line"><span class="meta">#</span> 如果安装异常，请先执行以下代码</span><br><span class="line">xcode-select --install</span><br><span class="line">sudo xcode-select -switch /</span><br></pre></td></tr></table></figure></li><li><p>Scrapy 安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install Scrapy</span><br><span class="line">scrapy</span><br></pre></td></tr></table></figure></li><li><p>Scrapy-Splash 安装<br>Scrapy 中支持 ::JavaScript 渲染的工具::、使用 Splash 的 HTTP API 进行页面渲染</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 安装 docker</span><br><span class="line">brew cask install docker</span><br><span class="line"><span class="meta">#</span> 安装 splash</span><br><span class="line">docker run -p 8050:8050 scrapinghub/splash # -d 参数：以守护态运行</span><br><span class="line">pip3 install scrapy-splash</span><br></pre></td></tr></table></figure></li><li><p>Scrapy-Redis 安装<br>scrapy 的分布式扩展模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install scrapy-redis</span><br></pre></td></tr></table></figure></li></ul><h2 id="部署相关库的安装"><a href="#部署相关库的安装" class="headerlink" title="部署相关库的安装"></a>部署相关库的安装</h2><p>大规模抓取数据的时候，一定会用到::分布式爬虫::：将一份代码，同时部署到多台主机上来协同运行。<br>方式一：Scrapyd、Scrapyd-Client、Scrapyd API<br>方式二：docker 集群部署</p><ul><li>Docker 安装</li></ul><p>一种容器技术，将::应用和环境::等进行::打包::，形成一个独立的”应用”。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew cask install docker</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>镜像加速<br>默认是从国外的 Docker Hub 下载的，当然可以使用国内的镜像来加速下载</p><ul><li><p>Scrapyd 安装<br>一个用于部署和运行 Scrapy 项目的工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install scrapyd</span><br></pre></td></tr></table></figure></li><li><p>Scrapyd-Client 安装<br>将 Scrapyd 代码部署到远程 Scrapyd 时，首先将代码打包为 EGG 文件，然后需要将 EGG 文件上传到远程主机。Scrapyd-Client 已经实现了这些功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install scrapyd-client</span><br><span class="line">scrapyd-deploy -h</span><br></pre></td></tr></table></figure></li><li><p>Scrapyd API 安装<br>安装好 Scrapyd 之后，可以直接请求它提供的 ::API:: 来获取当前主机的 Scrapyd 任务运行状况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install python-scrapyd-api</span><br></pre></td></tr></table></figure></li><li><p>Scrapyrt 安装<br>为 Scrapy 提供了一个::调度的 HTTP 接口::，可以直接请求 HTTP 接口来调度 Scrapy 任务。如果不需要分布式多任务的话，可以简单的使用 Scrapyrt 实现远程 Scrapy 任务的调度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pip3 install scrapyrt</span><br><span class="line"><span class="meta">#</span> 在任意一个 Scrapy 项目中，执行以下命令来启动 HTTP 服务</span><br><span class="line">scrapyrt</span><br><span class="line"><span class="meta">#</span> 或者 Docker 启动：运行在 9080 端口，且本地 Scrapy 项目的路径为 ： /home/quotesbot</span><br><span class="line">docker run -p 9080:9080 -tid -v /home/user/quotesbot:/scrapyrt/poject scrapinghub/scrapyrt</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">* Gerapy 安装</span><br><span class="line">一个 Scrapy ::分布式管理模块::</span><br><span class="line">```shell</span><br><span class="line">pip3 install gerapy</span><br></pre></td></tr></table></figure></li></ul><p>#学习/Python3网络爬虫开发实战/工具安装</p>]]></content>
      
      <categories>
          
          <category> Python网络爬虫技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Mac </tag>
            
            <tag> Python3 </tag>
            
            <tag> 网络爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MAC selenium webdriver 环境搭建</title>
      <link href="/2019/01/12/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/MAC%20selenium%20webdriver%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/01/12/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/MAC%20selenium%20webdriver%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MAC-selenium-webdriver-环境搭建"><a href="#MAC-selenium-webdriver-环境搭建" class="headerlink" title="MAC selenium webdriver 环境搭建"></a>MAC selenium webdriver 环境搭建</h1><p>1、查看是否安装 python（本人系统：10.13.6，自带 Python 2.7.10）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure></p><p>2、安装并查看 pip<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo easy_install pip</span><br><span class="line">pip --version</span><br></pre></td></tr></table></figure></p><p>3、安装 WebDriver（selenium）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo easy_install selenium # 貌似需要sudo安装</span><br></pre></td></tr></table></figure></p><p>4、下载浏览器驱动（chrome/firefox/phantomjs）</p><ul><li><p>chrome 驱动下载网址：<br>①、<a href="http://chromedriver.chromium.org/downloads" target="_blank" rel="noopener">http://chromedriver.chromium.org/downloads</a> <br>②、<a href="http://npm.taobao.org/mirrors/chromedriver/" target="_blank" rel="noopener">http://npm.taobao.org/mirrors/chromedriver/</a><br><br>将文件保存至本地磁盘，比如：/Users/username/Tools/chromedriver<br>移动到 usr/local/bin 目录下（确保 ~/.bash_profile 中已经加入 export PATH=/usr/local/bin:$PATH）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Users/username/Tools/</span><br><span class="line">mv chromedriver /usr/local/bin/</span><br></pre></td></tr></table></figure></li><li><p>firefox 驱动下载网址：<a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">https://github.com/mozilla/geckodriver/releases</a></p></li></ul><ul><li>brew 安装：如安装 phantomjs（注意：phantomjs 貌似不支持模拟移动设备）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew update &amp;&amp; brew install phantomjs</span><br></pre></td></tr></table></figure></li></ul><p>5、开始写测试脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 executable_path 指定 chrome 驱动文件所在路径</span></span><br><span class="line">driver = webdriver.Chrome(executable_path=<span class="string">"chromedriver"</span>)</span><br><span class="line"></span><br><span class="line">driver.set_window_size(<span class="string">"400"</span>, <span class="string">"600"</span>)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://m.baidu.com"</span></span><br><span class="line">driver.get(url)</span><br><span class="line">elem = driver.find_elements_by_css_selector(<span class="string">'#index-kw'</span>)</span><br><span class="line"><span class="comment"># 在输入框中输入 java</span></span><br><span class="line">elem[<span class="number">0</span>].send_keys(<span class="string">'java'</span>)</span><br><span class="line"><span class="comment"># 等待是为了方便查看浏览器效果</span></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">click = driver.find_elements_by_css_selector(<span class="string">'#index-bn'</span>)</span><br><span class="line"><span class="comment"># 点百度一下</span></span><br><span class="line">click[<span class="number">0</span>].click()</span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>1、selenium 3.x 版本开始，不再提供默认浏览器支持，都是通过各个浏览器提供驱动进行支持。</p><p>2、注意各个驱动及浏览器的版本对应关系，否则将可能无法调起浏览器。</p><p><a href="https://blog.csdn.net/xqhadoop/article/details/77892796" target="_blank" rel="noopener">https://blog.csdn.net/xqhadoop/article/details/77892796</a></p><p><a href="https://blog.csdn.net/huilan_same/article/details/51896672" target="_blank" rel="noopener">https://blog.csdn.net/huilan_same/article/details/51896672</a></p><h3 id="异常处理："><a href="#异常处理：" class="headerlink" title="异常处理："></a>异常处理：</h3><p>问题一：</p><blockquote><p>dyld: Library not loaded: /usr/local/opt/openssl/lib/libssl.1.0.0.dylib</p></blockquote><p>解决：重装 openssl<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew remove openssl</span><br><span class="line">brew install openssl</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python网络爬虫技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Mac </tag>
            
            <tag> selenium </tag>
            
            <tag> Python3 </tag>
            
            <tag> 网络爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Centos 7 部署 selenium + chrome + chromedriver</title>
      <link href="/2018/12/24/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/Centos%207%20%E9%83%A8%E7%BD%B2%20selenium%20+%20chrome%20+%20chromedriver/"/>
      <url>/2018/12/24/Python/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E6%8A%80%E6%9C%AF/Centos%207%20%E9%83%A8%E7%BD%B2%20selenium%20+%20chrome%20+%20chromedriver/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Centos-7-部署-selenium-chrome-chromedriver"><a href="#Centos-7-部署-selenium-chrome-chromedriver" class="headerlink" title="Centos 7 部署 selenium + chrome + chromedriver"></a>Centos 7 部署 selenium + chrome + chromedriver</h1><p>版本要求：<br>selenium &gt;= 3.14</p><h2 id="确定可以访问外网"><a href="#确定可以访问外网" class="headerlink" title="确定可以访问外网"></a>确定可以访问外网</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route # 查看默认网关</span><br><span class="line">route add default gw 网关（如：xx.xx.xx.1）</span><br></pre></td></tr></table></figure><h2 id="NO-1-安装-chrome"><a href="#NO-1-安装-chrome" class="headerlink" title="NO.1 安装 chrome"></a>NO.1 安装 chrome</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl https://intoli.com/install-google-chrome.sh | bash</span><br><span class="line">google-chrome-stable --version # 查看版本，确认是否安装成功</span><br></pre></td></tr></table></figure><h2 id="NO-2-安装-chromedriver"><a href="#NO-2-安装-chromedriver" class="headerlink" title="NO.2 安装 chromedriver"></a>NO.2 安装 chromedriver</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://chromedriver.storage.googleapis.com/2.43/chromedriver_linux64.zip</span><br><span class="line">unzip chromedriver_linux64.zip</span><br><span class="line">sudo mv chromedriver /usr/local/bin/</span><br><span class="line">chromedriver -v # 查看版本，确认是否安装成功</span><br></pre></td></tr></table></figure><h2 id="NO-3-安装-java-8"><a href="#NO-3-安装-java-8" class="headerlink" title="NO.3 安装 java-8"></a>NO.3 安装 java-8</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">wget --no-cookies --no-check-certificate --header "Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie" "http://download.oracle.com/otn-pub/java/jdk/8u141-b15/336fa29ff2bb4ef291e347e091f7f4a7/jdk-8u141-linux-x64.tar.gz"</span><br><span class="line">tar -xvf jdk-8u141-linux-x64.tar.gz</span><br><span class="line">sudo mv jdk1.8.0_141/ /opt/</span><br><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span> 写入以下代码</span><br><span class="line">export JAVA_HOME=/opt/jdk1.8.0_141</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"><span class="meta">#</span> 使配置生效</span><br><span class="line">source ~/.bashrc </span><br><span class="line">java -version</span><br></pre></td></tr></table></figure><h2 id="NO-4-更新-yum-源-amp-安装-git"><a href="#NO-4-更新-yum-源-amp-安装-git" class="headerlink" title="NO.4 更新 yum 源 &amp; 安装 git"></a>NO.4 更新 yum 源 &amp; 安装 git</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd  /etc/yum.repos.d</span><br><span class="line">sudo wget http://mirrors.163.com/.help/CentOS6-Base-163.repo</span><br><span class="line">sudo yum update</span><br><span class="line">sudo vim /etc/yum.repos.d/wandisco-git.repo</span><br><span class="line"><span class="meta">#</span> 写入以下代码</span><br><span class="line">[wandisco-git]</span><br><span class="line">name=Wandisco GIT Repository</span><br><span class="line">baseurl=http://opensource.wandisco.com/centos/7/git/$basearch/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br><span class="line"></span><br><span class="line">sudo rpm --import http://opensource.wandisco.com/RPM-GPG-KEY-WANdisco</span><br><span class="line">sudo yum install git</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><h2 id="NO-5-安装-pip"><a href="#NO-5-安装-pip" class="headerlink" title="NO.5 安装 pip"></a>NO.5 安装 pip</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum -y install epel-release</span><br><span class="line">sudo yum install python-pip</span><br><span class="line">sudo pip install --upgrade pip</span><br></pre></td></tr></table></figure><h2 id="NO-6-安装-selenium-并下载-selenium-server-standalone-3-14-0-jar"><a href="#NO-6-安装-selenium-并下载-selenium-server-standalone-3-14-0-jar" class="headerlink" title="NO.6 安装 selenium 并下载 selenium-server-standalone-3.14.0.jar"></a>NO.6 安装 selenium 并下载 selenium-server-standalone-3.14.0.jar</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --user selenium</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> chrome </tag>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Celery signature</title>
      <link href="/2018/11/04/Celery/Celery%20signature/"/>
      <url>/2018/11/04/Celery/Celery%20signature/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-signature"><a href="#Celery-signature" class="headerlink" title="Celery signature"></a>Celery signature</h1><h2 id="什么是-signature？"><a href="#什么是-signature？" class="headerlink" title="什么是 signature？"></a>什么是 signature？</h2><p>前面介绍了可以通过 delay 和 apply_async 来执行一个任务，多数情况下这已经足够使用，但是有时候你希望能够<strong>将任务调用的签名传递给另一个进程或者作为另一个函数的签名时</strong>，现有的方法就不够用了。</p><p>在 Celery 中，任务签名包含了<strong>一次任务调用的参数</strong>、<strong>关键字参数</strong>以及<strong>执行选项信息</strong>，它可以传递给其他函数，甚至序列化后通过网络传输。</p><h2 id="如何创建-signature？"><a href="#如何创建-signature？" class="headerlink" title="如何创建 signature？"></a>如何创建 signature？</h2><h3 id="通过任务的-signature-方法，创建任务签名对象"><a href="#通过任务的-signature-方法，创建任务签名对象" class="headerlink" title="通过任务的 signature 方法，创建任务签名对象"></a>通过任务的 <strong>signature 方法</strong>，创建任务签名对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.signature((<span class="number">2</span>, <span class="number">2</span>), countdown=<span class="number">10</span>)</span><br><span class="line">tasks.add(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="通过快捷方法，创建任务签名对象："><a href="#通过快捷方法，创建任务签名对象：" class="headerlink" title="通过快捷方法，创建任务签名对象："></a>通过快捷方法，创建任务签名对象：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.s(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">tasks.add(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h2 id="如何执行-signature？"><a href="#如何执行-signature？" class="headerlink" title="如何执行 signature？"></a>如何执行 signature？</h2><h3 id="直接执行"><a href="#直接执行" class="headerlink" title="直接执行"></a>直接执行</h3><p>签名在当前进程中执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s_add = add.signature((<span class="number">2</span>, <span class="number">2</span>), countdown=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s_add()</span><br></pre></td></tr></table></figure><h3 id="Worker-执行"><a href="#Worker-执行" class="headerlink" title="Worker 执行"></a>Worker 执行</h3><p>签名在 Worker 任务进程中执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s_add = add.s(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s_add.delay()</span><br></pre></td></tr></table></figure><p>跟一般的任务函数对比，区别在于<strong>签名可能已经指定了参数签名</strong>。</p><p>该add任务有两个参数，因此指定两个参数的签名将构成<strong>一个完整的签名</strong>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = add.s(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = s1.delay()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.get()</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure></p><p>但是，您也可以<strong>创建不完整的签名</strong>来创建的我们称之为 partials（偏函数）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># incomplete partial: add(?, 2)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = add.s(<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>s2 现在是一个部分签名，需要另一个参数完成，这可以在调用签名时解决：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># resolves the partial: add(8, 2)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = s2.delay(<span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res.get()</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>在这里，你添加参数8，形成了完整的签名。add(8, 2)</p><p><strong>关键字参数</strong>也可以在以后添加，<strong>覆盖掉</strong>任何现有的关键字参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s3 = add.s(2, 2, debug=True)</span><br><span class="line">&gt;&gt;&gt; s3.delay(debug=False)   # debug is now False.</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Celery </tag>
            
            <tag> Python </tag>
            
            <tag> 分布式任务队列 </tag>
            
            <tag> 签名 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Celery 定时任务</title>
      <link href="/2018/11/04/Celery/Celery%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2018/11/04/Celery/Celery%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-定时任务"><a href="#Celery-定时任务" class="headerlink" title="Celery 定时任务"></a>Celery 定时任务</h1><p>Celery 除了可以执行<strong>异步任务</strong>，也支持执行<strong>周期性任务（Periodic Tasks）</strong>，或者说<strong>定时任务</strong>。<br><br><strong>Celery Beat 进程</strong>通过<strong>读取配置文件的内容，周期性地将定时任务发往任务队列</strong>。</p><p>让我们看看例子，项目结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">celery_demo                    # 项目根目录</span><br><span class="line">    ├── celery_app             # 存放 celery 相关文件</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        ├── celeryconfig.py    # 配置文件</span><br><span class="line">        ├── task1.py           # 任务文件</span><br><span class="line">        └── task2.py           # 任务文件</span><br></pre></td></tr></table></figure><p>__init__.py 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'demo'</span>)                                <span class="comment"># 创建 Celery 实例</span></span><br><span class="line">app.config_from_object(<span class="string">'celery_app.celeryconfig'</span>)   <span class="comment"># 通过 Celery 实例加载配置模块</span></span><br></pre></td></tr></table></figure><p>celeryconfig.py 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"></span><br><span class="line"><span class="comment"># Broker and Backend</span></span><br><span class="line">BROKER_URL = <span class="string">'redis://127.0.0.1:6379'</span></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://127.0.0.1:6379/0'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Timezone</span></span><br><span class="line">CELERY_TIMEZONE=<span class="string">'Asia/Shanghai'</span>    <span class="comment"># 指定时区，不指定默认为 'UTC'</span></span><br><span class="line"><span class="comment"># CELERY_TIMEZONE='UTC'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># import</span></span><br><span class="line">CELERY_IMPORTS = (</span><br><span class="line">    <span class="string">'celery_app.task1'</span>,</span><br><span class="line">    <span class="string">'celery_app.task2'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># schedules</span></span><br><span class="line">CELERYBEAT_SCHEDULE = &#123;</span><br><span class="line">    <span class="string">'add-every-30-seconds'</span>: &#123;</span><br><span class="line">         <span class="string">'task'</span>: <span class="string">'celery_app.task1.add'</span>,</span><br><span class="line">         <span class="string">'schedule'</span>: timedelta(seconds=<span class="number">30</span>),       <span class="comment"># 每 30 秒执行一次</span></span><br><span class="line">         <span class="string">'args'</span>: (<span class="number">5</span>, <span class="number">8</span>)                           <span class="comment"># 任务函数参数</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'multiply-at-some-time'</span>: &#123;</span><br><span class="line">        <span class="string">'task'</span>: <span class="string">'celery_app.task2.multiply'</span>,</span><br><span class="line">        <span class="string">'schedule'</span>: crontab(hour=<span class="number">9</span>, minute=<span class="number">50</span>),   <span class="comment"># 每天早上 9 点 50 分执行一次</span></span><br><span class="line">        <span class="string">'args'</span>: (<span class="number">3</span>, <span class="number">7</span>)                            <span class="comment"># 任务函数参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>task1.py 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p>task2.py 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure></p><p>现在，让我们启动 <strong>Celery Worker 进程</strong>，在项目的根目录下执行下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyDolphin:celery_demo zhouyonglong01$  celery -A celery_app worker --loglevel=info</span><br></pre></td></tr></table></figure><p>接着，启动 <strong>Celery Beat 进程</strong>，定时将任务发送到 Broker，在项目根目录下执行下面命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyDolphin:celery_demo zhouyonglong01$ celery beat -A celery_app</span><br></pre></td></tr></table></figure></p><p>启动成功，看到如下日志：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">celery beat v4.2.1 (windowlicker) is starting.</span><br><span class="line">__    -    ... __   -        _</span><br><span class="line">LocalTime -&gt; 2018-11-04 16:55:42</span><br><span class="line">Configuration -&gt;</span><br><span class="line">    . broker -&gt; amqp://guest:**@localhost:5672//</span><br><span class="line">    . loader -&gt; celery.loaders.app.AppLoader</span><br><span class="line">    . scheduler -&gt; celery.beat.PersistentScheduler</span><br><span class="line">    . db -&gt; celerybeat-schedule</span><br><span class="line">    . logfile -&gt; [stderr]@%WARNING</span><br><span class="line">    . maxinterval -&gt; 5.00 minutes (300s)</span><br></pre></td></tr></table></figure></p><p>之后，在 Worker 窗口我们可以看到，<strong>任务 task1 每 30 秒执行一次</strong>，而 task2 每天早上 9 点 50 分执行一次。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[2018-11-04 16:56:13,233: INFO/MainProcess] Received task: celery_app.task1.add[3e9324d4-a27b-44a1-b530-d7dcb2c4f27a]</span><br><span class="line">[2018-11-04 16:56:15,254: INFO/ForkPoolWorker-2] Task celery_app.task1.add[3e9324d4-a27b-44a1-b530-d7dcb2c4f27a] succeeded in 2.01500433599s: 13</span><br><span class="line">[2018-11-04 16:56:43,082: INFO/MainProcess] Received task: celery_app.task1.add[e7e1d632-23d9-4c26-9292-d6d56fef70c4]</span><br><span class="line">[2018-11-04 16:56:45,098: INFO/ForkPoolWorker-3] Task celery_app.task1.add[e7e1d632-23d9-4c26-9292-d6d56fef70c4] succeeded in 2.01342217601s: 13</span><br><span class="line">[2018-11-04 16:57:13,082: INFO/MainProcess] Received task: celery_app.task1.add[88467637-a0a7-4357-a17a-b9e564d65d05]</span><br><span class="line">[2018-11-04 16:57:15,085: INFO/ForkPoolWorker-2] Task celery_app.task1.add[88467637-a0a7-4357-a17a-b9e564d65d05] succeeded in 2.00195308999s: 13</span><br></pre></td></tr></table></figure></p><p><strong>PS：在上面，我们用两个命令启动了 Worker 进程和 Beat 进程，我们也可以将它们放在一个命令中：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyDolphin:celery_demo zhouyonglong01$ celery -B -A celery_app worker --loglevel=info</span><br></pre></td></tr></table></figure></p><p>Celery 周期性任务也有多个配置项，可参考<a href="http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Celery </tag>
            
            <tag> Python </tag>
            
            <tag> 分布式任务队列 </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Celery 调用方法 delay &amp; apply_async 的区别</title>
      <link href="/2018/11/04/Celery/Celery%20%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%20delay%20&amp;%20apply_async%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/11/04/Celery/Celery%20%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%20delay%20&amp;%20apply_async%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-调用方法-delay-amp-apply-async-的区别"><a href="#Celery-调用方法-delay-amp-apply-async-的区别" class="headerlink" title="Celery 调用方法 delay &amp; apply_async 的区别"></a>Celery 调用方法 delay &amp; apply_async 的区别</h1><p>之前的例子，我们使用了 <strong>delay()</strong> 或 <strong>apply_async()</strong> 方法来调用任务。事实上，<strong>delay 方法封装了 apply_async</strong>，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">(self, *partial_args, **partial_kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Shortcut to :meth:`apply_async` using star arguments."""</span></span><br><span class="line">    <span class="keyword">return</span> self.apply_async(partial_args, partial_kwargs)</span><br></pre></td></tr></table></figure><p>也就是说，delay 是使用 <strong>apply_async 的快捷方式</strong>。<strong>apply_async 支持更多的参数</strong>，它的一般形式如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply_async(args=(), kwargs=&#123;&#125;, route_name=<span class="keyword">None</span>, **options)</span><br></pre></td></tr></table></figure></p><p>apply_async 常用的参数如下：</p><ul><li>countdown：<strong>指定多少秒后执行任务</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">task1.apply_async(args=(<span class="number">2</span>, <span class="number">3</span>), countdown=<span class="number">5</span>)    <span class="comment"># 5 秒后执行任务</span></span><br></pre></td></tr></table></figure><ul><li><p>eta (estimated time of arrival)：<strong>指定任务被调度的具体时间，参数类型是 datetime</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="comment"># 当前 UTC 时间再加 10 秒后执行任务</span></span><br><span class="line">task1.multiply.apply_async(args=[<span class="number">3</span>, <span class="number">7</span>], eta=datetime.utcnow() + timedelta(seconds=<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li><li><p>expires：<strong>任务过期时间，参数类型可以是 int，也可以是 datetime</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task1.multiply.apply_async(args=[3, 7], expires=10)    # 10 秒后过期</span><br></pre></td></tr></table></figure></li></ul><p>更多的参数列表可以在<a href="http://docs.celeryproject.org/en/latest/reference/celery.app.task.html#celery.app.task.Task.apply_async" target="_blank" rel="noopener">官方文档</a>中查看。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Celery </tag>
            
            <tag> Python </tag>
            
            <tag> 分布式任务队列 </tag>
            
            <tag> 调用方法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Celery 使用配置</title>
      <link href="/2018/11/04/Celery/Celery%20%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/11/04/Celery/Celery%20%E4%BD%BF%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-使用配置"><a href="#Celery-使用配置" class="headerlink" title="Celery 使用配置"></a>Celery 使用配置</h1><p>在较大的项目中，采用独立配置模块（中心化保存配置）更为有效，通常我们把文件命名为 celeryconfig.py。Celery 的配置比较多，可以在<a href="http://docs.celeryproject.org/en/latest/userguide/configuration.html" target="_blank" rel="noopener">官方文档</a>查询每个配置项的含义。</p><p>下面，我们再看一个例子。项目结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">celery_demo                    # 项目根目录</span><br><span class="line">    ├── celery_app             # 存放 celery 相关文件</span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── celeryconfig.py    # 配置文件</span><br><span class="line">    │   ├── task1.py           # 任务文件 1</span><br><span class="line">    │   └── task2.py           # 任务文件 2</span><br><span class="line">    └── client.py              # 应用程序</span><br></pre></td></tr></table></figure></p><p>__init__.py 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"></span><br><span class="line">app = Celery(<span class="string">'demo'</span>)                                <span class="comment"># 创建 Celery 实例</span></span><br><span class="line">app.config_from_object(<span class="string">'celery_app.celeryconfig'</span>)   <span class="comment"># 通过 Celery 实例加载配置模块</span></span><br></pre></td></tr></table></figure><p>celeryconfig.py 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">BROKER_URL = <span class="string">'amqp://guest@localhost:5672//'</span>        <span class="comment"># 指定 Broker</span></span><br><span class="line"></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://127.0.0.1:6379'</span>    <span class="comment"># 指定 Backend</span></span><br><span class="line"></span><br><span class="line">CELERY_TIMEZONE=<span class="string">'Asia/Shanghai'</span>                     <span class="comment"># 指定时区，默认是 UTC</span></span><br><span class="line"><span class="comment"># CELERY_TIMEZONE='UTC'                             </span></span><br><span class="line"></span><br><span class="line">CELERY_IMPORTS = (                                  <span class="comment"># 指定导入的任务模块</span></span><br><span class="line">    <span class="string">'celery_app.task1'</span>,</span><br><span class="line">    <span class="string">'celery_app.task2'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>task1.py 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure></p><p>task2.py 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x * y</span><br></pre></td></tr></table></figure></p><p>client.py 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> task1</span><br><span class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> task2</span><br><span class="line"></span><br><span class="line">task1.add.apply_async(args=[<span class="number">2</span>, <span class="number">8</span>])        <span class="comment"># 也可用 task1.add.delay(2, 8)</span></span><br><span class="line">task2.multiply.apply_async(args=[<span class="number">3</span>, <span class="number">7</span>])   <span class="comment"># 也可用 task2.multiply.delay(3, 7)</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure></p><p>现在，让我们启动 Celery Worker 进程，在项目的根目录下执行下面命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TinyDolphin:celery_demo zhouyonglong01$ celery -A celery_app worker --loglevel=info</span><br></pre></td></tr></table></figure></p><p>接着，运行 python client.py，它会发送两个异步任务到 Broker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TinyDolphin:celery_demo zhouyonglong01$ python client.py</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>在 Worker 的窗口我们可以看到如下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[2018-11-04 16:15:26,449: INFO/MainProcess] Received task: celery_app.task1.add[44051062-fdf9-41d0-bccb-6a393c1f2eab]</span><br><span class="line">[2018-11-04 16:15:26,450: INFO/MainProcess] Received task: celery_app.task2.multiply[b3183cc3-0565-4359-b21f-d7fb7c2e22a2]</span><br><span class="line">[2018-11-04 16:15:28,466: INFO/ForkPoolWorker-2] Task celery_app.task1.add[44051062-fdf9-41d0-bccb-6a393c1f2eab] succeeded in 2.012861372s: 10</span><br><span class="line">[2018-11-04 16:15:28,466: INFO/ForkPoolWorker-4] Task celery_app.task2.multiply[b3183cc3-0565-4359-b21f-d7fb7c2e22a2] succeeded in 2.01327455899s: 21</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Celery </tag>
            
            <tag> Python </tag>
            
            <tag> 分布式任务队列 </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Celery 异步任务</title>
      <link href="/2018/11/04/Celery/Celery%20%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
      <url>/2018/11/04/Celery/Celery%20%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-异步任务"><a href="#Celery-异步任务" class="headerlink" title="Celery 异步任务"></a>Celery 异步任务</h1><p>使用 Celery 实现异步任务主要有三个步骤：</p><ol><li>创建一个 Celery 实例；</li><li>启动 Celery worker；</li><li>应用程序调用异步任务。</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="选择-broker-amp-backend"><a href="#选择-broker-amp-backend" class="headerlink" title="选择 broker &amp; backend"></a>选择 broker &amp; backend</h3><ol><li><strong>RabbitMQ</strong>功能齐全，稳定，耐用且易于安装。它是生产环境的绝佳选择。（官网推荐使用）</li><li><strong>Redis</strong>功能齐全，但在突然终止或电源故障时更容易丢失数据</li></ol><p>如果选择以上两种 broker，则需要分别安装，可参考<a href="http://tinydolphin.cn/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Redis/" target="_blank" rel="noopener">Mac 安装 Redis</a> &amp; <a href="http://tinydolphin.cn/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Rabbitmq/" target="_blank" rel="noopener">Mac 安装 Rabbitmq</a> 。</p><h3 id="安装-Celery"><a href="#安装-Celery" class="headerlink" title="安装 Celery"></a>安装 Celery</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install celery</span><br></pre></td></tr></table></figure><h2 id="创建-Celery-任务"><a href="#创建-Celery-任务" class="headerlink" title="创建 Celery 任务"></a>创建 Celery 任务</h2><p>将下面的代码保存为文件 tasks.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">broker = <span class="string">'amqp://guest@localhost:5672//'</span></span><br><span class="line">backend = <span class="string">'redis://127.0.0.1:6379'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Celery 实例</span></span><br><span class="line"><span class="comment"># 第一个参数：当前模板的名称。只有在 __main__ 模板中定义任务时才能自动生成名称。</span></span><br><span class="line"><span class="comment"># 第二个参数：指定使用的消息中间件的 URL</span></span><br><span class="line"><span class="comment"># 第三个参数：指定任务结果存储的 URL</span></span><br><span class="line">app = Celery(<span class="string">'tasks'</span>, broker=broker, backend=backend)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个名为 add 的单个任务：返回两个数的总和</span></span><br><span class="line"><span class="comment"># 创建了一个 Celery 任务 add，当函数被 @app.task 装饰后，就成为可被 Celery 调度的任务</span></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)   <span class="comment"># 模拟耗时操作</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure><h2 id="启动-Celery-worker"><a href="#启动-Celery-worker" class="headerlink" title="启动 Celery worker"></a>启动 Celery worker</h2><p>在当前目录下，使用以下指令启动 Celery worker：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery worker -A tasks --loglevel=info</span><br></pre></td></tr></table></figure></p><p>其中，</p><ul><li>参数 -A 指定了 Celery 实例的位置，本例是在 tasks.py 中，Celery 会自动在该文件中寻找 Celery 对象实例，当然，我们也可以自己指定，在本例，使用 -A tasks.app。</li><li>参数 –loglevel 指定了日志级别，默认为 warning，也可以使用 -l info 来表示；</li></ul><p>启动成功后，控制台会显示如下输出：</p><p><img src="/images/celery启动成功.jpg" alt="celery启动成功.jpg"></p><h2 id="调度任务"><a href="#调度任务" class="headerlink" title="调度任务"></a>调度任务</h2><p>现在，我们可以在应用程序中使用 <strong>delay()</strong> 或 <strong>apply_async()</strong> 方法来调用任务。</p><p>在当前目录打开 Python 控制台，输入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> tasks <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add.delay(<span class="number">1</span>, <span class="number">20</span>)</span><br><span class="line">&lt;AsyncResult: d91cb44d-e4b5<span class="number">-489</span>b<span class="number">-9</span>dbf<span class="number">-982</span>ae2b39e0d&gt;</span><br></pre></td></tr></table></figure><p>在上面，我们从 tasks.py 文件中<strong>导入了 add 任务对象，然后使用 delay() 方法将任务发送到消息中间件（Broker），Celery Worker 进程监控到该任务后，就会进行执行</strong>。我们将窗口切换到 Worker 的启动窗口，会看到多了两条日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[2018-11-04 15:43:25,351: INFO/MainProcess] Received task: tasks.add[d91cb44d-e4b5-489b-9dbf-982ae2b39e0d]</span><br><span class="line">[2018-11-04 15:43:25,386: INFO/ForkPoolWorker-2] Task tasks.add[d91cb44d-e4b5-489b-9dbf-982ae2b39e0d] succeeded in 0.0192078250111s: 21</span><br></pre></td></tr></table></figure><p>这说明任务已经被调度并执行成功。</p><p>PS：我们如果想获取执行后的结果，可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = add.delay(<span class="number">10</span>, <span class="number">42</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()  <span class="comment"># 使用 ready() 判断任务是否执行完毕</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.ready()</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result.get()    <span class="comment"># 使用 get() 获取任务结果</span></span><br><span class="line"><span class="number">52</span></span><br></pre></td></tr></table></figure><p>注意：虽然执行 add 方法 5s 之后才会返回结果，但是这是一个异步任务，不会阻塞主程序的，因此主程序并不会等待，而是会继续向下执行。</p><h2 id="后台启动-Celery-worker"><a href="#后台启动-Celery-worker" class="headerlink" title="后台启动 Celery worker"></a>后台启动 Celery worker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">celery multi start worker -A tasks -l info</span><br><span class="line">celery multi restart worker -A tasks -l info</span><br><span class="line"># 不等待worker关闭</span><br><span class="line">celery multi stop worker -A tasks -l info</span><br><span class="line"># 等待worker关闭</span><br><span class="line">celery multi stopwait worker -A tasks -l info</span><br><span class="line"></span><br><span class="line">celery multi start w1 -A project -l info</span><br><span class="line">celery multi start w2 -A project -l info</span><br><span class="line">celery multi start w3 -A project -l info</span><br><span class="line"># 立即停止w1,w2</span><br><span class="line">celery multi stop w1 w2</span><br></pre></td></tr></table></figure><p>注意：celery multi 不会存储有关 worker 的信息，因此在<strong>重启时，需要使用相同的命令行参数</strong>。<strong>停止时，只能使用相同的 pidfile 和 logfile 参数</strong>。</p><p>默认情况下，它会<strong>在当前目录中创建pid和日志文件，以防止多个工作人员在彼此之上启动</strong>，但是推荐你将这些文件放在专用目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/run/celery</span><br><span class="line">mkdir -p /var/log/celery</span><br><span class="line">celery multi start w1 -A proj -l info --pidfile=/var/run/celery/%n.pid --logfile=/var/log/celery/%n%I.log</span><br></pre></td></tr></table></figure><p>使用multi命令可以<strong>启动多个worker</strong>，并且还有一个强大的命令行语法来为不同的worker指定参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery multi start 10 -A proj -l info -Q:1-3 images,video -Q:4,5 data -Q default -L:4,5 debug</span><br></pre></td></tr></table></figure></p><p>有关更多示例，请参考<a href="http://docs.celeryproject.org/en/master/reference/celery.bin.multi.html#module-celery.bin.multi" target="_blank" rel="noopener">官方文档</a>。</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Celery </tag>
            
            <tag> Python </tag>
            
            <tag> 分布式任务队列 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Celery 框架及其使用场景</title>
      <link href="/2018/11/04/Celery/Celery%20%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/2018/11/04/Celery/Celery%20%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Celery-框架及其使用场景"><a href="#Celery-框架及其使用场景" class="headerlink" title="Celery 框架及其使用场景"></a>Celery 框架及其使用场景</h1><p>celery 是一款基于 python 开发的、专注于<strong>实时处理</strong>和<strong>任务调度</strong>的<strong>分布式任务队列</strong>。</p><h2 id="Celery-架构以及组成部分"><a href="#Celery-架构以及组成部分" class="headerlink" title="Celery 架构以及组成部分"></a>Celery 架构以及组成部分</h2><p><img src="/images/celery.jpg" alt="Celery 框架图"></p><p>可以看到，Celery 主要包含以下几个模块：</p><h3 id="任务模板-Task"><a href="#任务模板-Task" class="headerlink" title="任务模板 Task"></a>任务模板 Task</h3><p><strong>异步任务：</strong>通常在业务逻辑中<strong>被触发</strong>并发往任务队列。<br><br><strong>定时任务：</strong>由 <strong>Celery Beat</strong> 进程<strong>周期性</strong>地将任务发往任务队列。</p><h3 id="消息中间件-Broker"><a href="#消息中间件-Broker" class="headerlink" title="消息中间件 Broker"></a>消息中间件 Broker</h3><p>即为<strong>任务调度队列</strong>，<strong>接收任务生产者发来的消息（即任务），将任务存入队列，再按序分发给任务消费者</strong>。Celery 本身不提供队列服务，官方推荐使用 RabbitMQ 和 Redis 等。</p><h3 id="任务执行单元-Worker"><a href="#任务执行单元-Worker" class="headerlink" title="任务执行单元 Worker"></a>任务执行单元 Worker</h3><p>Worker 是执行任务的处理单元，它<strong>实时监控消息队列，获取队列中调度的任务，并执行它</strong>。</p><h3 id="任务结果存储-Backend"><a href="#任务结果存储-Backend" class="headerlink" title="任务结果存储 Backend"></a>任务结果存储 Backend</h3><p>Backend 用于<strong>存储任务的执行结果，以供查询</strong>。同消息中间件一样，存储也可使用 RabbitMQ, Redis 和 MongoDB 等。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p><strong>例子一：在程序的运行过程中，经常会碰到一些耗时耗资源的操作，为了避免它们阻塞主程序的运行，我们经常会采用多线程或异步任务。</strong></p><p>比如：在 web 开发中，对新用户的注册，我们通常会给他发一封激活邮件，而发邮件就是 IO阻塞式任务，如果它们直接放到应用当中，就需要等到邮件发出去之后，才能进行下一步操作，此时用户只有一直等待。</p><p>celery 解决方案：在业务逻辑中<strong>触发一个发邮件的异步任务</strong>，而主程序可以继续往下运行。</p><p><strong>例子二：在程序运行的过程中，有一个要运行很久的任务，但是我们又不想阻塞主程序</strong>。</p><ol><li>解决方案：使用多线程。但是当<strong>并发量过大</strong>时，多线程也会扛不住</li><li>继续解决：使用线程池来限制并发数。<ul><li>多线程对于<strong>共享资源</strong>的使用也是比较麻烦的一件事。</li><li>对于<strong>协程</strong>，它还是在同一个线程中执行的，如果一个任务本身的执行时间很长，而不是因为等待 IO 被挂起的，那么也同样会阻塞其他的协程。</li></ul></li><li>最终方案：基于以上的问题，我们可以使用一个强大的分布式任务队列 Celery 来<strong>让任务的执行和主程序完全的脱离</strong>，甚至不在同一个主机内。通过<strong>队列</strong>来调度任务，所以不用担心并发量高时导致系统负载过大。</li></ol><p><strong>例子三：执行和主程序脱离</strong></p><p>你想对100台机器执行一条批量命令，可能会花很长时间 ，但你不想让你的程序等着结果返回，而是给你返回一个任务ID,你过一段时间只需要拿着这个任务id就可以拿到任务执行结果，这样的话，在任务执行进行时，你可以继续做其它的事情。</p><p><strong>例子四：做一个定时任务</strong></p><p>比如每天定时检测一下你们所有客户的资料，如果发现今天是客户的生日，就给他发个短信祝福</p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Celery </tag>
            
            <tag> Python </tag>
            
            <tag> 分布式任务队列 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</title>
      <link href="/2018/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%B5%85%E6%9E%90%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E3%80%81%E5%B9%B3%E5%9D%87%E3%80%81%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2018/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%B5%85%E6%9E%90%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E3%80%81%E5%B9%B3%E5%9D%87%E3%80%81%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"><a href="#复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度" class="headerlink" title="复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度"></a>复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</h1><p>主要四个复杂度分析方面的知识点：<strong>最好情况时间复杂度</strong>、<strong>最坏情况时间复杂度</strong>、<strong>平均情况时间复杂度</strong>、<strong>均摊时间复杂度</strong></p><h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] <span class="built_in">array</span>, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，我们上一节简单的分析方法，解决不了这个问题。</p><p>第一种情况：如果数组中第一个元素正好是要查找的变量 x ，那么就不需要继续遍历剩下的 n - 1 个数据了，那么时间复杂度：O(1)</p><p>第二种情况：如果数组中不存在要查找的变量 x ，那就需要把整个数组都遍历一遍，时间复杂度就成了：O(n)</p><p>所以：不同的情况下，这段代码的复杂度不一样。</p><p>①、<strong>最好情况时间复杂度</strong>就是，在<strong>最理想</strong>的情况下，执行这段代码的时间复杂度。</p><p>②、<strong>最坏情况时间复杂度</strong>就是，在<strong>最糟糕</strong>的情况下，执行这段代码的时间复杂度。</p><h2 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h2><h3 id="不考虑变量-x-在数组中出现的概率问题（结论正确，但是分析过程有点问题）"><a href="#不考虑变量-x-在数组中出现的概率问题（结论正确，但是分析过程有点问题）" class="headerlink" title="不考虑变量 x 在数组中出现的概率问题（结论正确，但是分析过程有点问题）"></a>不考虑变量 x 在数组中出现的概率问题（结论正确，但是分析过程有点问题）</h3><p>拿上面的代码来分析，要查找变量 x 在数组中的位置，有 n + 1 种情况：<strong>在数组 0 ~ n -1 位置中和不在数组中</strong>。这样的话，我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n + 1 ，就可以得到需要遍历的元素个数的平均值了，即：(1 + 2 + 3 …… + n + n ) / (n+1) = n(n+3) / 2(n+1) 。</p><p>但是在时间复杂度大 O 标记法中，可以省略掉系数、低阶、常量，所以简化之后，得到的平均时间复杂度就是 O(n)。</p><h3 id="考虑变量-x-在数组中出现的概率问题"><a href="#考虑变量-x-在数组中出现的概率问题" class="headerlink" title="考虑变量 x 在数组中出现的概率问题"></a>考虑变量 x 在数组中出现的概率问题</h3><p>为了方便理解，我们假设在数组中和不在数组中的概率都为 1/2 。要查找的数据出现在 0 ~ n-1 这 n 个位置的概率也是一样的，为 1/n 。所以，根据概率乘法法则，要查找的元素出现在 0 ~ n-1 中任意位置的概率为 1/(2n)。</p><p>那么考虑概率的话，计算过程：1 <em> 1/(2n) + 2 </em> 1/(2n) + 3 <em> 1/(2n) + …… + n </em> 1/(2n) + n * 1/2 = (1+3n)/4 ，用大 O 表示法来表示，这段代码的加权平均时间复杂度仍然是 O(n) 。</p><p>这个值就是概率论中的<strong>加权平均值</strong>，也叫做<strong>期望值</strong>，所以<strong>平均时间复杂度</strong>的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p><h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现的功能：往数组中插入数据。当数组满了之后，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，再将新的数据插入。</span></span><br><span class="line"><span class="comment">// array 表示一个长度为 n 的数组</span></span><br><span class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"><span class="keyword">int</span>[] <span class="built_in">array</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (count == <span class="built_in">array</span>.length) &#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.length; ++i) &#123;</span><br><span class="line">         sum = sum + <span class="built_in">array</span>[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">array</span>[<span class="number">0</span>] = sum;</span><br><span class="line">      count = <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">array</span>[count] = val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用之前的方式去分析时间复杂度"><a href="#利用之前的方式去分析时间复杂度" class="headerlink" title="利用之前的方式去分析时间复杂度"></a>利用之前的方式去分析时间复杂度</h3><p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置即可，所以最好情况时间复杂度为 O(1)。</p><p>最坏的情况下，数组中没有空闲空间，我们需要做一次数组遍历求和，然后再将数据插入，所以最坏的情况为 O(n) </p><p>平均时间复杂度下，根据数据插入的位置不同，我们可以分为 n 种情况，每种情况的时间复杂度为 O(1) 。除此之外，还有一种”额外”的情况，就是在数组没有空闲空间的插入一个数据时，时间复杂度为 O(n)，而且这 n + 1 种情况发生的概率一样，都是 1/(n+1) 。所以，根据加权平均的计算方法，我们可以得到平均时间复杂度：1 <em> 1/(n+1) + 1 </em> 1/(n+1) + 1 <em> 1/(n+1) …… 1 </em> 1/(n+1) + n * 1/(n+1) = 2n/(n+1) —&gt; O(1) </p><h3 id="利用摊还分析法去分析时间复杂度"><a href="#利用摊还分析法去分析时间复杂度" class="headerlink" title="利用摊还分析法去分析时间复杂度"></a>利用摊还分析法去分析时间复杂度</h3><p><strong>①、首先来看看 insert() 与 find() 的区别：</strong></p><ul><li>find() 函数在极端的情况下，复杂度才为 O(1) ，但 <strong>insert() 在大多数情况下，时间复杂度都为 O(1)</strong>，只有个别情况下，复杂度才为 O (n) ；</li><li>对于 insert() 函数来说，O(1) 时间复杂度的插入和O(n) 时间复杂度的插入，出现的频率非常的有规律，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟 n-1 个O(1) 的插入操作，循环往复。 </li></ul><p>基于以上两种不同，我们可以引入一种更加简单的分析方法：摊还分析法。通过这种方法得到的时间复杂度，就叫做：<strong>均摊时间复杂度</strong>。</p><p><strong>②、如何使用摊还分析法来分析算法的均摊时间复杂度</strong></p><p>大致思路：每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时小的操作上，均摊下来，这一组的连续的操作的均摊时间复杂度就是 O(1) 。</p><p>均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。其实<strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>对一个数据结构进行一组连续的操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块分析，看是否能够将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且这种情况下，一般均摊时间复杂度就等于最好情况时间复杂度。</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</title>
      <link href="/2018/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%EF%BC%9F/"/>
      <url>/2018/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"><a href="#复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？" class="headerlink" title="复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？"></a>复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</h1><p><strong>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半</strong></p><blockquote><p><strong>Q：为什么需要复杂度分析？</strong></p><p>A：首页对于这个问题有所疑惑：明明可以把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小（某些书中的”事后统计法”）。为什么还需要复杂度分析呢？</p><p>因为这种方法存在很大的<strong>局限性</strong>：</p><p>①、<strong>测试结果非常的依赖测试环境</strong><br><br>    不同的测试环境，得到的结果可能完全不同。</p><p>②、<strong>测试结果受数据规模的影响很大</strong><br><br>    比如：排序算法中，对于不一样的待排序数据有序度，排序的执行时间就有很大的差别。（对于小规模的数据排序，插入排序可能反倒会比快速排序要快！）</p><p>所以，我们需要一个<strong>不用具体的测试数据来测试</strong>，就可以<strong>粗略地估算出算法的执行效率</strong>的方法——<strong>时间、空间复杂度分析</strong>。</p></blockquote><h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2><p>我们假设每一段代码的执行时间为 t</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;             <span class="comment">// 一个 t 的执行时间 </span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;               <span class="comment">// t</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;    <span class="comment">// n * t</span></span><br><span class="line">    sum = sum + i;         <span class="comment">// n * t</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 所以这段代码的总的执行时间 T(n) = (2n+2)*t 。可以看出：<strong>总的代码执行时间 T(n) 与每行代码的执行次数成正比</strong>。</p><p>所以，这段代码的大 O 时间复杂度表示法： <strong>T(n) = O(f(n))</strong></p><p>其中：T(n)：代码总的执行时间、n：数据规模的大小、f(n) 每行代码执行的次数总和、O ：代码的执行时间 T(n) 与 f(n) 表达式成正比</p><p>大 O 时间复杂度表示法：并不具体表示代码的真正执行时间，而是表示<strong>代码执行时间随着数据规模增长的变化趋势</strong>。也叫 <strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong></p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><h3 id="1、只关注循环执行次数最大的一段代码"><a href="#1、只关注循环执行次数最大的一段代码" class="headerlink" title="1、只关注循环执行次数最大的一段代码"></a>1、只关注循环执行次数最大的一段代码</h3><p>既然说大 O 复杂度是一种变化趋势，那么我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;<span class="comment">// 常量级别的执行时间，与 n 无关，可以忽略</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;<span class="comment">// 同上</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;<span class="comment">// n</span></span><br><span class="line">    sum = sum + i;<span class="comment">// n</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以以上代码，总的时间复杂度：O(n)</p><h3 id="2、加法规则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2、加法规则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2、加法规则：总复杂度等于量级最大的那段代码的复杂度"></a>2、加法规则：总复杂度等于量级最大的那段代码的复杂度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">true<span class="comment">// 常量级别</span></span><br><span class="line">   <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line">true<span class="comment">// O(n) 级别</span></span><br><span class="line">   <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="comment">// O(n²) 级别</span></span><br><span class="line">   <span class="keyword">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以以上代码，总的时间复杂度：T(n) = T1(n) + T2(n) + T3(n) = O(1) + O(n) + O(n²) = O(n²) </p><p>如果 T1(n) = O(f(n))、T2(n) = O(g(n))；那么T(n) = T1(n) + T2(n) = Max(O(f(n),  g(n)))</p><h3 id="3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3、乘法规则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">true<span class="comment">// O(n) 级别</span></span><br><span class="line">   <span class="keyword">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// O(n) 级别</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>所以以上代码，总的时间复杂度：T = T1(n) <em> T2(n) = O(n </em> n) = O(n²) </p><p>如果 T1(n) = O(f(n))、T2(n) = O(g(n))；那么T(n) = T1(n) <em> T2(n) = O(f(n) </em> g(n))</p><h2 id="几种常见的时间复杂度实例分析"><a href="#几种常见的时间复杂度实例分析" class="headerlink" title="几种常见的时间复杂度实例分析"></a>几种常见的时间复杂度实例分析</h2><h3 id="1、多项式时间复杂度"><a href="#1、多项式时间复杂度" class="headerlink" title="1、多项式时间复杂度"></a>1、多项式时间复杂度</h3><p>常量阶 O(1)、对数阶 O(logn)、线性阶 O(n)、线性对数阶 O(nlogn)、平方阶 O(n²)、立方阶 O(n³) …… K方阶 O(n^k)</p><h4 id="①、O-1"><a href="#①、O-1" class="headerlink" title="①、O(1)"></a>①、O(1)</h4><p>一般情况下，只要算法中不存在循环语句，递归语句，就算有成千上万行代码，其时间复杂度依然是 O(1)</p><h4 id="②、O-logn、nlogn"><a href="#②、O-logn、nlogn" class="headerlink" title="②、O(logn、nlogn)"></a>②、O(logn、nlogn)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设第三行代码的执行次数为 x ，则可以得到 2^x = n，进而得到 x = log2(n) 。所以这段代码的时间复杂度为 O(log2(n))。</p><p>由于前面我们说过，<strong>在使用大O标记复杂度的时候，可以忽略系数</strong>。所以，在对数阶时间复杂度的时候，我们忽略对数的底，统一表示为 O(logn)</p><h4 id="③、O-n-m-、O-n-m"><a href="#③、O-n-m-、O-n-m" class="headerlink" title="③、O(n+m)、O(n*m)"></a>③、O(n+m)、O(n*m)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，出现两个无法预知 n、m 的数据规模量级大小，所以不能简单的利用加法法则，省略掉其中一个。所以以上代码的时间复杂度：T1(n) + T1(m) = O(f(n) + g(m)) = O(n+m)。</p><p>虽然此时加法法则无效，但是乘法法则依然有效：T1(n) <em> T2(m) = O(f(n) </em> g(m))  = O(n * m)</p><h3 id="2、非多项式时间复杂度（非常低效的方法，直接略）"><a href="#2、非多项式时间复杂度（非常低效的方法，直接略）" class="headerlink" title="2、非多项式时间复杂度（非常低效的方法，直接略）"></a>2、非多项式时间复杂度（非常低效的方法，直接略）</h3><p>指数阶 O(2^n)、阶乘阶 O(n!) 。</p><p>对于这个时间复杂度，会随着数据规模的增长，算法的执行时间会急剧增加。所以非常的低效。</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>前面讲过，时间复杂度的全称是<strong>渐进时间复杂度</strong>，表示<strong>算法的执行时间与数据规模之间的增长关系</strong>。那么类比一下，<strong>空间复杂度</strong>就是<strong>渐进空间复杂度</strong>，表示<strong>算法的存储空间与数据规模之间的增长关系</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 常量阶，申请了一个空间存储变量 i</span></span><br><span class="line">  <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">// 一个大小为 n 的 int 型数组</span></span><br><span class="line">  <span class="keyword">for</span> (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i = n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以，以上的空间复杂度：O(n) </p><p>常见的空间复杂度：O(1)、O(n)、O(n²)，像 O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都要分析一下时间复杂度、空间复杂度是不是很浪费时间呢？你怎么看待这个问题呢？</p>]]></content>
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac 安装 brew 以及部分使用指令</title>
      <link href="/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20%20brew%20%E4%BB%A5%E5%8F%8A%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
      <url>/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20%20brew%20%E4%BB%A5%E5%8F%8A%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-安装-brew-以及部分使用指令"><a href="#Mac-安装-brew-以及部分使用指令" class="headerlink" title="Mac 安装 brew 以及部分使用指令"></a>Mac 安装 brew 以及部分使用指令</h1><h3 id="NO-1-官网获取下载指令"><a href="#NO-1-官网获取下载指令" class="headerlink" title="NO.1 官网获取下载指令"></a>NO.1 官网获取下载指令</h3><p><a href="http://brew.sh/" target="_blank" rel="noopener">http://brew.sh/</a></p><p>Homebrew安装成功后，会自动创建目录 /usr/local/Cellar 来存放Homebrew安装的程序</p><h3 id="NO-2-使用-brew"><a href="#NO-2-使用-brew" class="headerlink" title="NO.2 使用 brew"></a>NO.2 使用 brew</h3><ul><li>安装软件：brew install 软件名，例：brew install wget</li><li>搜索软件：brew search 软件名，例：brew search wget</li><li>卸载软件：brew uninstall 软件名，例：brew uninstall wget</li><li>更新所有软件：brew update</li><li>更新具体软件：brew upgrade 软件名 ，例：brew upgrade git</li><li>显示已安装软件：brew list</li><li>查看软件信息：brew info／home 软件名 ，例：brew info git ／ brew home git<br>PS：brew home指令是用浏览器打开官方网页查看软件信息</li><li>查看哪些已安装的程序需要更新： brew outdated</li><li>显示包依赖：brew reps</li><li>显示帮助：brew help</li></ul>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac 安装 Rabbitmq</title>
      <link href="/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Rabbitmq/"/>
      <url>/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Rabbitmq/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-安装-Rabbitmq"><a href="#Mac-安装-Rabbitmq" class="headerlink" title="Mac 安装 Rabbitmq"></a>Mac 安装 Rabbitmq</h1><h3 id="NO-1-Mac-下安装-Rabbitmq"><a href="#NO-1-Mac-下安装-Rabbitmq" class="headerlink" title="NO.1 Mac 下安装 Rabbitmq"></a>NO.1 Mac 下安装 Rabbitmq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" # 安装 brew（Homebrew：Mac OS平台下的软件包管理工具）</span><br><span class="line">brew install rabbitmq</span><br><span class="line">sudo vim ~/.bash_profile</span><br><span class="line">PATH=$PATH:/usr/local/sbin # 最后一行加上</span><br></pre></td></tr></table></figure><h3 id="NO-2-启动-amp-停止-Rabbitmq"><a href="#NO-2-启动-amp-停止-Rabbitmq" class="headerlink" title="NO.2 启动 &amp; 停止 Rabbitmq"></a>NO.2 启动 &amp; 停止 Rabbitmq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动服务</span><br><span class="line">brew services start rabbitmq</span><br><span class="line"><span class="meta">#</span> 停止服务</span><br><span class="line">brew services stop rabbitmq</span><br><span class="line"><span class="meta">#</span> 启用插件</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"><span class="meta">#</span> 禁用插件</span><br><span class="line">rabbitmq-plugins disable rabbitmq_management</span><br></pre></td></tr></table></figure><h3 id="NO-3-进入控制台"><a href="#NO-3-进入控制台" class="headerlink" title="NO.3 进入控制台"></a>NO.3 进入控制台</h3><p><a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a></p><p>默认用户名和密码：guest , guest</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Rabbitmq </category>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Celery </tag>
            
            <tag> 工具 </tag>
            
            <tag> Mac </tag>
            
            <tag> Rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac 安装 Redis</title>
      <link href="/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Redis/"/>
      <url>/2018/09/17/%E5%B7%A5%E5%85%B7/Mac%20%E5%AE%89%E8%A3%85%20Redis/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-安装-Redis"><a href="#Mac-安装-Redis" class="headerlink" title="Mac 安装 Redis"></a>Mac 安装 Redis</h1><h3 id="NO-1-Mac-下安装-Redis"><a href="#NO-1-Mac-下安装-Redis" class="headerlink" title="NO.1 Mac 下安装 Redis"></a>NO.1 Mac 下安装 Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure><h3 id="NO-2-启动-amp-停止-Rabbitmq"><a href="#NO-2-启动-amp-停止-Rabbitmq" class="headerlink" title="NO.2 启动 &amp; 停止 Rabbitmq"></a>NO.2 启动 &amp; 停止 Rabbitmq</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 启动Redis服务</span><br><span class="line">brew services start redis</span><br><span class="line"><span class="meta">#</span> 关闭Redis服务</span><br><span class="line">brew services stop redis</span><br><span class="line"><span class="meta">#</span> 重启Redis服务</span><br><span class="line">brew services restart redis</span><br><span class="line"><span class="meta">#</span> 打开图形化界面</span><br><span class="line">redis-cli</span><br></pre></td></tr></table></figure><h3 id="NO-3-redise的配置文件所在路径"><a href="#NO-3-redise的配置文件所在路径" class="headerlink" title="NO.3 redise的配置文件所在路径"></a>NO.3 redise的配置文件所在路径</h3><p>/usr/local/etc/redis.conf</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Redis </category>
          
          <category> Celery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Celery </tag>
            
            <tag> 工具 </tag>
            
            <tag> Mac </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>POJ 1852 Ants</title>
      <link href="/2018/09/15/ACM/POJ/1852/"/>
      <url>/2018/09/15/ACM/POJ/1852/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="POJ-1852-Ants"><a href="#POJ-1852-Ants" class="headerlink" title="POJ 1852 Ants"></a>POJ 1852 Ants</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    POJ:1852</span></span><br><span class="line"><span class="comment">    题意：简单的理解就是， N 只蚂蚁以 1cm/s 的速度在，一条长 L 厘米的竿子上爬行（不知道初始的爬行方向），当蚂蚁爬到竿子的端点时会掉落。</span></span><br><span class="line"><span class="comment">        但竿子太细了，如果有两只蚂蚁相遇时，它们只能各自反向爬回去。</span></span><br><span class="line"><span class="comment">        对于蚂蚁，我们只知道它们距离竿子左端的距离 xi，但不知道当前蚂蚁的朝向</span></span><br><span class="line"><span class="comment">        请计算所有蚂蚁落下竿子所需要的最短时间和最长时间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    迷惑条件：如果有两只蚂蚁相遇时，它们只能各自反向爬回去。</span></span><br><span class="line"><span class="comment">    转换思路：其实不管相遇后各自反向爬 OR 相遇后保持原方向爬行，结果都是一样的。</span></span><br><span class="line"><span class="comment">    这样的话，最短时间 = MAX（所有蚂蚁距离竿子端点的最近距离）</span></span><br><span class="line"><span class="comment">            最长时间 = MAX（所有蚂蚁距离竿子端点的最远距离）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"iostream"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000010 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,l,x[MAX_N];</span><br><span class="line"><span class="keyword">int</span> maxT, minT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    minT = <span class="number">0</span>;</span><br><span class="line">    maxT = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++)&#123;</span><br><span class="line">        minT = max(minT, min(x[i], l - x[i]));</span><br><span class="line">        maxT = max(maxT, max(x[i], l - x[i]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l , &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        solve();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, minT, maxT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACM </tag>
            
            <tag> POJ </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JetBrains系开发工具激活</title>
      <link href="/2018/09/11/%E5%B7%A5%E5%85%B7/JetBrains%E7%B3%BB%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%BF%80%E6%B4%BB/"/>
      <url>/2018/09/11/%E5%B7%A5%E5%85%B7/JetBrains%E7%B3%BB%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E6%BF%80%E6%B4%BB/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>NO.1</strong></p><p>将“0.0.0.0 account.jetbrains.com”添加到 <strong>hosts 文件末尾处</strong></p><p>hosts 文件所在目录：</p><ul><li><p>Windows：C:\Windows\System32\drivers\etc\hosts</p></li><li><p>Mac：/etc/hosts</p></li></ul><p><strong>NO.2</strong></p><p>进入 <a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a> ，获得注册码即可。</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac终端添加ll、la、l命令</title>
      <link href="/2018/09/10/%E5%B7%A5%E5%85%B7/Mac%E7%BB%88%E7%AB%AF%E6%B7%BB%E5%8A%A0ll%E3%80%81la%E3%80%81l%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/09/10/%E5%B7%A5%E5%85%B7/Mac%E7%BB%88%E7%AB%AF%E6%B7%BB%E5%8A%A0ll%E3%80%81la%E3%80%81l%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac终端添加ll、la、l命令"><a href="#Mac终端添加ll、la、l命令" class="headerlink" title="Mac终端添加ll、la、l命令"></a>Mac终端添加ll、la、l命令</h1><h3 id="NO-1-编辑-bash-profile文件"><a href="#NO-1-编辑-bash-profile文件" class="headerlink" title="NO.1 编辑.bash_profile文件"></a>NO.1 编辑.bash_profile文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><h3 id="NO-2-添加别名映射关系"><a href="#NO-2-添加别名映射关系" class="headerlink" title="NO.2 添加别名映射关系"></a>NO.2 添加别名映射关系</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alias ll='ls -alF'</span><br><span class="line">alias la='ls -A'</span><br><span class="line">alias l='ls -CF'</span><br></pre></td></tr></table></figure><h3 id="NO-3-source-文件"><a href="#NO-3-source-文件" class="headerlink" title="NO.3 source 文件"></a>NO.3 source 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac如何重置root用户密码</title>
      <link href="/2018/09/10/%E5%B7%A5%E5%85%B7/Mac%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEroot%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
      <url>/2018/09/10/%E5%B7%A5%E5%85%B7/Mac%E5%A6%82%E4%BD%95%E9%87%8D%E7%BD%AEroot%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</url>
      <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac如何重置root用户密码？"><a href="#Mac如何重置root用户密码？" class="headerlink" title="Mac如何重置root用户密码？"></a>Mac如何重置root用户密码？</h1><p>1、打开终端，输入：sudo bash，提示输入当前用户密码</p><p>2、成功进入bash命令模式之后，输入 sudo passwd root</p><p>3、输入新的 root 密码即可</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
